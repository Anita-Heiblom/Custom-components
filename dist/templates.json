[{"name":"DataList","type":"CONTAINER_COMPONENT","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"<div className={classes.root}>\n\t\t\t{(() => {\n    const {\n      env,\n      getProperty,\n      GetMe,\n      InteractionScope,\n      ModelProvider,\n      useAllQuery,\n      useFilter\n    } = B;\n    const [page, setPage] = useState(1);\n    const [search, setSearch] = useState('');\n    const [searchTerm, setSearchTerm] = useState('');\n    const [isTyping, setIsTyping] = useState(false);\n    const {\n      take,\n      filter,\n      overrideFilter,\n      externalFilterType,\n      searchTimeOut,\n      type,\n      model,\n      authProfile,\n      showError,\n      hideSearch,\n      searchProperty,\n      order,\n      orderBy,\n      pagination\n    } = options;\n    const rowsPerPage = parseInt(take, 10) || 50;\n    const {\n      TextField,\n      InputAdornment\n    } = window.MaterialUI.Core;\n    const {\n      Search\n    } = window.MaterialUI.Icons;\n    const {\n      label: searchPropertyLabel\n    } = getProperty(searchProperty) || {};\n    const isEmpty = children.length === 0;\n    const isDev = env === 'dev';\n    const isPristine = isEmpty && isDev;\n    const displayError = showError === 'built-in';\n    const listRef = React.createRef();\n    const [showPagination, setShowPagination] = useState(true);\n    const isInline = type === 'inline';\n    const isGrid = type === 'grid';\n    const [newFilter, setNewFilter] = useState({});\n\n    const builderLayout = () => <>\n\t\t\t\t\t\t{searchProperty && !hideSearch && <div className={classes.header}>\n\t\t\t\t\t\t\t\t<SearchComponent label={searchPropertyLabel} />\n\t\t\t\t\t\t\t</div>}\n\t\t\t\t\t\t<div ref={listRef} className={isGrid && classes.grid}>\n\t\t\t\t\t\t\t<div className={[isEmpty ? classes.empty : '', isPristine ? classes.pristine : '', isInline ? classes.inline : ''].filter(Boolean).join(' ') || undefined}>\n\t\t\t\t\t\t\t\t{isPristine ? 'Drag a component in the data list to display the data' : children}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{isDev && showPagination && <div className={classes.footer}>\n\t\t\t\t\t\t\t\t<Pagination totalCount={0} resultCount={rowsPerPage} currentPage={1} />\n\t\t\t\t\t\t\t</div>}\n\t\t\t\t\t</>;\n\n    B.defineFunction('updateFilter', updatedFilter => {\n      if (updatedFilter.filter != undefined) {\n        setNewFilter(prevFilter => ({ ...prevFilter,\n          [updatedFilter.label]: updatedFilter.filter\n        }));\n      } else {\n        const filterCopy = { ...newFilter\n        };\n        delete filterCopy[updatedFilter.label];\n        setNewFilter(filterCopy);\n      }\n    });\n    useEffect(() => {\n      if (!isDev) return;\n\n      const repeat = () => {\n        if (!listRef.current) return;\n        const numberOfChildren = listRef.current.children.length;\n\n        if (numberOfChildren === 0) {\n          return;\n        }\n\n        for (let i = numberOfChildren - 1, j = 0; i > j; i -= 1) {\n          const child = listRef.current.children[i];\n\n          if (child) {\n            listRef.current.removeChild(child);\n          }\n        }\n\n        for (let i = 0, j = rowsPerPage - 1; i < j; i += 1) {\n          listRef.current.children[0].insertAdjacentHTML('afterend', listRef.current.children[0].outerHTML);\n        }\n\n        listRef.current.children.forEach((child, index) => {\n          if (index > 0) {\n            const elem = child;\n            elem.style.opacity = 0.4;\n            elem.style.pointerEvents = 'none';\n          }\n        });\n      };\n\n      const mutationObserver = new MutationObserver(() => {\n        repeat();\n      });\n      mutationObserver.observe(listRef.current.children[0], {\n        attributes: true,\n        characterData: true,\n        childList: true,\n        subtree: true,\n        attributeOldValue: false,\n        characterDataOldValue: false\n      });\n      repeat();\n    });\n\n    const handleSearch = event => {\n      setSearch(event.target.value);\n    };\n\n    const deepMerge = (...objects) => {\n      const isObject = item => item && typeof item === 'object' && !Array.isArray(item);\n\n      return objects.reduce((accumulator, object) => {\n        Object.keys(object).forEach(key => {\n          const accumulatorValue = accumulator[key];\n          const value = object[key];\n\n          if (Array.isArray(accumulatorValue) && Array.isArray(value)) {\n            accumulator[key] = accumulatorValue.concat(value);\n          } else if (isObject(accumulatorValue) && isObject(value)) {\n            accumulator[key] = deepMerge(accumulatorValue, value);\n          } else {\n            accumulator[key] = value;\n          }\n        });\n        return accumulator;\n      }, {});\n    };\n\n    const orderByArray = [orderBy].flat();\n    const sort = !isDev && orderBy ? orderByArray.reduceRight((acc, property, index) => {\n      const prop = getProperty(property);\n      return index === orderByArray.length - 1 ? {\n        [prop.name]: order.toUpperCase()\n      } : {\n        [prop.name]: acc\n      };\n    }, {}) : {};\n    let path = [searchProperty].flat();\n\n    if (typeof searchProperty.id !== 'undefined') {\n      path = [searchProperty.id].flat();\n    }\n\n    const searchFilter = searchProperty ? path.reduceRight((acc, property, index) => index === path.length - 1 ? {\n      _or: searchTerm.trim('').split(' ').map(term => {\n        return {\n          [property]: {\n            matches: term\n          }\n        };\n      })\n    } : {\n      [property]: acc\n    }, {}) : {};\n    const mergedFilter = searchProperty && searchTerm !== '' && overrideFilter || overrideFilter && Object.values(newFilter).length > 0 ? deepMerge(searchFilter) : searchProperty && searchTerm !== '' && !overrideFilter ? deepMerge(filter, searchFilter) : overrideFilter && Object.values(newFilter).length > 0 ? {} : filter;\n    const where = { ...useFilter(mergedFilter),\n      ...(Object.values(newFilter).length > 0 ? {\n        [externalFilterType]: Object.values(newFilter)\n      } : {})\n    };\n    const {\n      loading,\n      error,\n      data,\n      refetch\n    } = model && useAllQuery(model, {\n      rawFilter: where,\n      skip: page ? (page - 1) * rowsPerPage : 0,\n      take: rowsPerPage,\n      variables: { ...(orderBy ? {\n          sort: {\n            relation: sort\n          }\n        } : {})\n      },\n\n      onCompleted(res) {\n        const hasResult = res && res.result && res.result.length > 0;\n\n        if (hasResult) {\n          B.triggerEvent('onSuccess', res.results);\n        } else {\n          B.triggerEvent('onNoResults');\n        }\n      },\n\n      onError(resp) {\n        if (!displayError) {\n          B.triggerEvent('onError', resp);\n        }\n      }\n\n    });\n    useEffect(() => {\n      if (isDev) {\n        if (pagination === 'never') {\n          setShowPagination(false);\n        } else {\n          setShowPagination(true);\n        }\n      }\n    }, [pagination]);\n    useEffect(() => {\n      if (!isDev && data) {\n        switch (pagination) {\n          case 'never':\n            setShowPagination(false);\n            break;\n\n          case 'whenNeeded':\n            if (rowsPerPage >= data.totalCount) {\n              setShowPagination(false);\n            }\n\n            break;\n\n          default:\n          case 'always':\n            setShowPagination(true);\n        }\n      }\n    }, [data, rowsPerPage]);\n    useEffect(() => {\n      const handler = setTimeout(() => {\n        setSearchTerm(search);\n      }, searchTimeOut);\n      return () => {\n        clearTimeout(handler);\n      };\n    }, [search]);\n    B.defineFunction('Refetch', () => refetch());\n    B.defineFunction('SetSearchValue', event => {\n      setSearch(event.target.value);\n    });\n    const mounted = useRef(false);\n    useEffect(() => {\n      mounted.current = true;\n      return () => {\n        mounted.current = false;\n      };\n    }, []);\n    useEffect(() => {\n      if (mounted.current && loading) {\n        B.triggerEvent('onLoad', loading);\n      }\n    }, [loading]);\n\n    const handleClick = (event, context) => {\n      B.triggerEvent('OnItemClick', event, context);\n    };\n\n    const Looper = results => {\n      const rows = results.map(item => <ModelProvider key={item.id} value={item} id={model}>\n\t\t\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t\t\t{context => <div role='none' className={isInline && classes.inline} onClick={event => handleClick(event, context)}>\n\t\t\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t\t\t</div>}\n\t\t\t\t\t\t\t</InteractionScope>\n\t\t\t\t\t\t</ModelProvider>);\n\n      if (authProfile) {\n        return <GetMe authenticationProfileId={authProfile}>{rows}</GetMe>;\n      }\n\n      return rows;\n    };\n\n    const canvasLayout = () => {\n      if (!model) {\n        return builderLayout();\n      }\n\n      if (loading) return <div className={classes.skeleton} />;\n\n      if (error && displayError) {\n        return <span>{error.message}</span>;\n      }\n\n      const {\n        results = [],\n        totalCount\n      } = data || {};\n      const resultCount = results && results.length;\n      return <>\n\t\t\t\t\t\t\t{searchProperty && !hideSearch && <div className={classes.header}>\n\t\t\t\t\t\t\t\t\t<SearchComponent label={searchPropertyLabel} onChange={handleSearch} value={search} isTyping={isTyping} setIsTyping={setIsTyping} />\n\t\t\t\t\t\t\t\t</div>}\n\n\t\t\t\t\t\t\t{!isGrid ? Looper(results) : <div className={classes.grid}>{Looper(results)}</div>}\n\n\t\t\t\t\t\t\t{showPagination && <div className={classes.footer}>\n\t\t\t\t\t\t\t\t\t<Pagination totalCount={totalCount} resultCount={resultCount} currentPage={page} />\n\t\t\t\t\t\t\t\t</div>}\n\t\t\t\t\t\t</>;\n    };\n    /* SubComponents */\n\n\n    function SearchComponent({\n      label,\n      onChange,\n      value,\n      // eslint-disable-next-line no-shadow\n      isTyping,\n      // eslint-disable-next-line no-shadow\n      setIsTyping\n    }) {\n      const inputRef = React.createRef();\n      useEffect(() => {\n        if (isTyping) {\n          inputRef.current.focus();\n        }\n      });\n      return <div className={classes.searchWrapper}>\n\t\t\t\t\t\t\t<TextField placeholder={`Search on ${label}`} InputProps={{\n          startAdornment: <InputAdornment position='start'>\n\t\t\t\t\t\t\t\t\t\t\t<Search />\n\t\t\t\t\t\t\t\t\t\t</InputAdornment>\n        }} onChange={onChange} inputRef={inputRef} onFocus={() => setIsTyping(true)} onBlur={() => setIsTyping(false)} value={value} />\n\t\t\t\t\t\t</div>;\n    }\n\n    function Pagination({\n      totalCount,\n      resultCount,\n      currentPage\n    }) {\n      const firstItem = currentPage ? (currentPage - 1) * rowsPerPage : 0;\n      useEffect(() => {\n        const totalPages = Math.ceil(totalCount / rowsPerPage);\n\n        if (currentPage > totalPages) {\n          setPage(totalPages);\n        }\n      }, [totalCount]);\n      const totalText = env === 'dev' ? '[total]' : totalCount;\n      return <>\n\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t{firstItem + 1}\n\t\t\t\t\t\t\t\t{firstItem + 1 !== totalCount && ` - ${firstItem + resultCount}`}{' '}\n\t\t\t\t\t\t\t\tof {totalText}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<div className={classes.pagination}>\n\t\t\t\t\t\t\t\t{typeof currentPage !== 'undefined' && currentPage > 1 ? <button className={classes.button} type='button' onClick={() => setPage(v => v - 1)}>\n\t\t\t\t\t\t\t\t\t\t<span className={[classes.arrow, 'zmdi zmdi-chevron-left'].join(' ')} />\n\t\t\t\t\t\t\t\t\t</button> : <span className={[classes.arrow, classes.arrowDisabled, 'zmdi zmdi-chevron-left'].join(' ')} />}\n\t\t\t\t\t\t\t\t{(typeof currentPage === 'undefined' ? 1 : currentPage) < totalCount / rowsPerPage ? <button className={classes.button} type='button' onClick={() => setPage(v => v + 1)}>\n\t\t\t\t\t\t\t\t\t\t<span className={[classes.arrow, 'zmdi zmdi-chevron-right'].join(' ')} />\n\t\t\t\t\t\t\t\t\t</button> : <span className={[classes.arrow, classes.arrowDisabled, 'zmdi zmdi-chevron-right'].join(' ')} />}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</>;\n    }\n\n    return isDev ? builderLayout() : canvasLayout();\n  })()}\n\t\t</div>","styles":"B => theme => {\n  const {\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    root: {\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3])\n    },\n    inline: {\n      display: 'inline-flex'\n    },\n    header: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      flexDirection: 'row-reverse',\n      width: '100%'\n    },\n    searchWrapper: {\n      display: 'flex',\n      alignItems: 'center',\n      padding: [0, '0.5rem'],\n      minHeight: '4rem'\n    },\n    searchIcon: {\n      fontSize: '1.25rem',\n      marginRight: '1rem'\n    },\n    search: {\n      padding: ['0.25rem', 0],\n      fontSize: '1rem',\n      border: 'none',\n      outline: 'none'\n    },\n    button: {\n      background: 'transparent',\n      border: 'none',\n      display: 'inline-block',\n      padding: 0,\n      margin: 0,\n      cursor: 'pointer',\n      '&:active': {\n        outline: 'none'\n      }\n    },\n    footer: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'flex-end',\n      padding: ['0.75rem', 0]\n    },\n    placeholder: {\n      opacity: '0.4'\n    },\n    pagination: {\n      marginLeft: '1rem'\n    },\n    arrow: {\n      padding: '1rem',\n      fontSize: '1.625rem',\n      color: '#000',\n      textDecoration: 'none'\n    },\n    arrowDisabled: {\n      color: '#ccc'\n    },\n    skeleton: {\n      height: `calc(${style.getFont('Body1').Mobile} * 1.2)`,\n      [`@media ${mediaMinWidth(600)}`]: {\n        height: `calc(${style.getFont('Body1').Portrait} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        height: `calc(${style.getFont('Body1').Landscape} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        height: `calc(${style.getFont('Body1').Desktop} * 1.2)`\n      },\n      backgroundColor: '#eee',\n      borderRadius: 8,\n      overflow: 'hidden',\n      '&::after': {\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        backgroundImage: 'linear-gradient(90deg, #eee 25%, #fff 50%, #eee 75%)',\n        backgroundSize: '200% 100%',\n        backgroundRepeat: 'no-repeat',\n        backgroundPositionX: '150%',\n        borderRadius: `calc(${style.getFont('Body2').Landscape} / 2)`,\n        content: '\"\"',\n        animation: 'loading 1.5s infinite'\n      }\n    },\n    [`@media ${mediaMinWidth(600)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Portrait'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Portrait'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Portrait'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Portrait')\n      }\n    },\n    [`@media ${mediaMinWidth(960)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Landscape'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Landscape'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Landscape'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Landscape')\n      }\n    },\n    [`@media ${mediaMinWidth(1280)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Desktop'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Desktop'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Desktop'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Desktop')\n      }\n    },\n    grid: {\n      display: 'grid',\n      gridTemplateColumns: ({\n        options: {\n          width\n        }\n      }) => `repeat(auto-fit, minmax(${width}, 1fr))`,\n      gridGap: ({\n        options: {\n          gap\n        }\n      }) => `${gap}`\n    },\n    empty: {\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      justifyContent: 'center',\n      minHeight: '4rem',\n      height: '100%',\n      width: '100%',\n      fontSize: '0.75rem',\n      color: '#262A3A',\n      textTransform: 'uppercase',\n      boxSizing: 'border-box'\n    },\n    pristine: {\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    }\n  };\n}","functions":["updateFilter","Refetch","SetSearchValue"],"triggers":["onSuccess","onNoResults","onError","onLoad","OnItemClick"]},{"name":"DataTable","type":"CONTENT_COMPONENT","allowedTypes":["DATATABLE_COLUMN"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Children,\n    env,\n    getProperty,\n    GetMe,\n    InteractionScope,\n    ModelProvider,\n    useAllQuery,\n    useFilter,\n    useText\n  } = B;\n  const {\n    Table,\n    TableBody,\n    TableContainer,\n    TableHead,\n    TableRow,\n    TableCell,\n    TablePagination,\n    Paper,\n    Toolbar,\n    TextField,\n    InputAdornment\n  } = window.MaterialUI.Core;\n  const {\n    Search\n  } = window.MaterialUI.Icons;\n  const isDev = env === 'dev';\n  const {\n    take,\n    size,\n    model,\n    authProfile,\n    filter,\n    searchProperty,\n    overrideFilter,\n    externalFilterType,\n    searchTimeOut,\n    hideSearch,\n    orderProperty,\n    sortOrder,\n    labelRowsPerPage,\n    labelNumberOfPages,\n    labelSearchOn,\n    square,\n    elevation,\n    variant,\n    stickyHeader,\n    title,\n    pagination,\n    linkTo,\n    showError,\n    autoLoadOnScroll,\n    autoLoadTakeAmount\n  } = options;\n  const repeaterRef = React.createRef();\n  const tableRef = React.createRef();\n  const tableContainerRef = React.createRef();\n  const displayError = showError === 'built-in';\n  const [page, setPage] = useState(0);\n  const takeNum = parseInt(take, 10);\n  const initialRender = useRef(true);\n  const skipAppend = useRef(false);\n  const [skip, setSkip] = useState(0);\n  const loadOnScroll = pagination === 'never' && autoLoadOnScroll;\n  const autoLoadTakeAmountNum = parseInt(autoLoadTakeAmount, 10);\n  const [rowsPerPage, setRowsPerPage] = useState(takeNum);\n  const [search, setSearch] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [showPagination, setShowPagination] = useState(false);\n  const {\n    label: searchPropertyLabel = '{property}'\n  } = getProperty(searchProperty) || {};\n  const [orderBy, setOrderBy] = React.useState({\n    field: [orderProperty].flat() || null,\n    order: orderProperty ? sortOrder : null\n  });\n  const [results, setResults] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n  const [previousSearchTerm, setPreviousSearchTerm] = useState('');\n  const [newSearch, setNewSearch] = useState(false);\n  const fetchingNextSet = useRef(false);\n  const [initialTimesFetched, setInitialTimesFetched] = useState(0);\n  const amountOfRows = loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage;\n  const history = isDev ? null : useHistory();\n  const [newFilter, setNewFilter] = useState({});\n\n  const createSortObject = (fields, order) => {\n    const fieldsArray = [fields].flat();\n    const sort = fieldsArray.reduceRight((acc, property, index) => {\n      const prop = getProperty(property);\n      return index === fieldsArray.length - 1 ? {\n        [prop.name]: order.toUpperCase()\n      } : {\n        [prop.name]: acc\n      };\n    }, {});\n    return sort;\n  };\n\n  const [variables, setVariables] = useState(orderProperty ? {\n    sort: {\n      relation: !isDev && createSortObject(orderProperty, sortOrder)\n    }\n  } : {});\n  const titleText = useText(title);\n  const hasToolbar = titleText || searchProperty && !hideSearch;\n  const elevationLevel = variant === 'flat' ? 0 : elevation;\n  const hasLink = linkTo && linkTo.id !== '';\n  const toolbarRef = React.createRef();\n  const paginationRef = React.createRef();\n  const [stylesProps, setStylesProps] = useState(null);\n  B.defineFunction('updateFilter', updatedFilter => {\n    if (updatedFilter.filter != undefined) {\n      setNewFilter(prevFilter => ({ ...prevFilter,\n        [updatedFilter.label]: updatedFilter.filter\n      }));\n    } else {\n      const filterCopy = { ...newFilter\n      };\n      delete filterCopy[updatedFilter.label];\n      setNewFilter(filterCopy);\n    }\n  });\n\n  const deepMerge = (...objects) => {\n    const isObject = item => item && typeof item === 'object' && !Array.isArray(item);\n\n    return objects.reduce((accumulator, object) => {\n      Object.keys(object).forEach(key => {\n        const accumulatorValue = accumulator[key];\n        const value = object[key];\n\n        if (Array.isArray(accumulatorValue) && Array.isArray(value)) {\n          accumulator[key] = accumulatorValue.concat(value);\n        } else if (isObject(accumulatorValue) && isObject(value)) {\n          accumulator[key] = deepMerge(accumulatorValue, value);\n        } else {\n          accumulator[key] = value;\n        }\n      });\n      return accumulator;\n    }, {});\n  };\n\n  let path = [searchProperty].flat();\n\n  if (typeof searchProperty.id !== 'undefined') {\n    path = [searchProperty.id].flat();\n  }\n\n  const searchFilter = searchProperty ? path.reduceRight((acc, property, index) => index === path.length - 1 ? {\n    _or: searchTerm.trim('').split(' ').map(term => {\n      return {\n        [property]: {\n          matches: term\n        }\n      };\n    })\n  } : {\n    [property]: acc\n  }, {}) : {};\n  const mergedFilter = searchProperty && searchTerm !== '' && overrideFilter || overrideFilter && Object.values(newFilter).length > 0 ? deepMerge(searchFilter) : searchProperty && searchTerm !== '' && !overrideFilter ? deepMerge(filter, searchFilter) : overrideFilter && Object.values(newFilter).length > 0 ? {} : filter;\n  const where = { ...useFilter(mergedFilter),\n    ...(Object.values(newFilter).length > 0 ? {\n      [externalFilterType]: Object.values(newFilter)\n    } : {})\n  }; // TODO: move model to skip\n\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = model && useAllQuery(model, {\n    rawFilter: where,\n    variables,\n    skip: loadOnScroll ? skip : page * rowsPerPage,\n    take: loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage,\n\n    onCompleted(res) {\n      const hasResult = res && res.result && res.result.length > 0;\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(err) {\n      if (!displayError) {\n        B.triggerEvent('onError', err);\n      }\n    }\n\n  });\n  useEffect(() => {\n    if (!isDev && data) {\n      if (pagination !== 'never') {\n        setResults(data.results);\n        setTotalCount(data.totalCount);\n        return;\n      }\n\n      if (searchTerm !== previousSearchTerm) {\n        setSkip(0);\n        setInitialTimesFetched(0);\n        setPreviousSearchTerm(searchTerm);\n        setNewSearch(true);\n      } else {\n        if (newSearch || !autoLoadOnScroll && skipAppend.current) {\n          setResults(data.results);\n        } else {\n          setResults(prev => [...prev, ...data.results]);\n        }\n\n        fetchingNextSet.current = false;\n        setNewSearch(false);\n      }\n\n      skipAppend.current = false;\n      setTotalCount(data.totalCount);\n    }\n  }, [data, searchTerm]);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setSearchTerm(search);\n    }, searchTimeOut);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [search]);\n\n  function clearResults() {\n    setInitialTimesFetched(0);\n    setResults([]);\n    setTimeout(() => {\n      setSkip(0);\n    }, 0);\n  }\n\n  B.defineFunction('Refetch', () => {\n    if (pagination === 'never') {\n      clearResults();\n      skipAppend.current = true;\n      setTimeout(() => {\n        refetch();\n      }, 0);\n    } else {\n      refetch();\n    }\n  });\n  B.defineFunction('SetSearchValue', event => {\n    setSearch(event.target.value);\n  });\n  useEffect(() => {\n    if (!isDev) return;\n\n    const repeat = () => {\n      if (!repeaterRef.current) return;\n\n      if (repeaterRef.current.previousElementSibling.children.length === 0) {\n        return;\n      }\n\n      repeaterRef.current.innerHTML = '';\n\n      for (let i = 0, j = amountOfRows - 1; i < j; i += 1) {\n        repeaterRef.current.innerHTML += repeaterRef.current.previousElementSibling.children[0].outerHTML;\n      }\n    };\n\n    const mutationObserver = new MutationObserver(() => {\n      repeat();\n    });\n    mutationObserver.observe(tableRef.current, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    repeat();\n  });\n  useEffect(() => {\n    setRowsPerPage(takeNum);\n  }, [takeNum]);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  const handleChangePage = (_, newPage) => {\n    if (loading || error) return;\n    setPage(newPage);\n  };\n\n  const handleChangeRowsPerPage = event => {\n    if (loading || error) return;\n    setRowsPerPage(parseInt(event.target.value, 10));\n    setPage(0);\n  };\n\n  const handleSort = (field, newOrder) => {\n    if (isDev) return;\n    setOrderBy({\n      field,\n      order: newOrder\n    });\n    setVariables({\n      sort: {\n        relation: createSortObject(field, newOrder)\n      }\n    });\n  };\n\n  const handleSearch = event => {\n    setSearch(event.target.value);\n  };\n\n  const handleRowClick = (endpoint, context) => {\n    if (isDev) return;\n    B.triggerEvent('OnRowClick', endpoint, context);\n\n    if (hasLink) {\n      history.push(endpoint);\n    }\n  };\n\n  const renderTableHead = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n\t\t\t\t\t\t<div className={classes.skeleton}>\n\t\t\t\t\t\t\t{error && displayError && error.message}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</TableCell>);\n    }\n\n    return <Children headerOnly handleSort={handleSort} orderBy={orderBy}>\n\t\t\t\t\t{children}\n\t\t\t\t</Children>;\n  };\n\n  const tableContentModel = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(rowsPerPage).keys()).map(idx => <TableRow key={idx} classes={{\n        root: classes.bodyRow\n      }}>\n\t\t\t\t\t\t{Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n\t\t\t\t\t\t\t\t<div className={classes.skeleton} />\n\t\t\t\t\t\t\t</TableCell>)}\n\t\t\t\t\t</TableRow>);\n    }\n\n    const rows = results.map(value => <ModelProvider value={value} id={model}>\n\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t{context => <TableRow key={value[0]} classes={{\n          root: classes.bodyRow\n        }} data-id={value.id}>\n\t\t\t\t\t\t\t\t<Children linkTo={linkTo} handleRowClick={handleRowClick} context={context}>\n\t\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t\t</Children>\n\t\t\t\t\t\t\t</TableRow>}\n\t\t\t\t\t</InteractionScope>\n\t\t\t\t</ModelProvider>);\n\n    if (authProfile) {\n      return <GetMe authenticationProfileId={authProfile}>{rows}</GetMe>;\n    }\n\n    return rows;\n  };\n\n  const renderTableContent = () => {\n    if (isDev) {\n      return <TableRow classes={{\n        root: classes.bodyRow\n      }}>{children}</TableRow>;\n    }\n\n    if (model) {\n      return tableContentModel();\n    }\n\n    return Array.from(Array(amountOfRows).keys()).map(idx => <TableRow key={idx} classes={{\n      root: classes.bodyRow\n    }}>\n\t\t\t\t\t{children}\n\t\t\t\t</TableRow>);\n  };\n\n  useEffect(() => {\n    if (loadOnScroll && !isDev) {\n      const fetchNextSet = () => {\n        fetchingNextSet.current = true;\n\n        if (!initialRender.current) {\n          setSkip(prev => prev + autoLoadTakeAmountNum);\n        }\n\n        initialRender.current = false;\n      };\n\n      const tableContainerElement = tableContainerRef.current;\n\n      if (loadOnScroll) {\n        const parent = tableContainerElement.parentNode;\n\n        if (tableContainerElement.scrollHeight <= parent.clientHeight && initialTimesFetched < 5) {\n          setInitialTimesFetched(prev => prev + 1);\n          fetchNextSet();\n        }\n\n        const scrollEvent = e => {\n          const {\n            scrollTop,\n            clientHeight,\n            scrollHeight\n          } = e.target;\n          const offset = scrollHeight / 5;\n          const hitBottom = scrollTop + clientHeight >= scrollHeight - offset;\n\n          if (hitBottom && !fetchingNextSet.current) {\n            fetchNextSet();\n          }\n        };\n\n        tableContainerElement.addEventListener('scroll', scrollEvent);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (pagination === 'never') {\n      const dataResults = data && data.results;\n      const needsCacheFix = results.length === 0 && dataResults && dataResults.length > 0;\n\n      const setExistingData = () => {\n        setResults(dataResults);\n        fetchingNextSet.current = false;\n      };\n\n      if (needsCacheFix && !autoLoadOnScroll) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip === 0) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip !== 0) {\n        setSkip(0);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (isDev) {\n      if (pagination === 'never') {\n        setShowPagination(false);\n      } else {\n        setShowPagination(true);\n      }\n    }\n  }, [pagination]);\n  useEffect(() => {\n    if (!isDev && data) {\n      switch (pagination) {\n        case 'never':\n          setShowPagination(false);\n          break;\n\n        case 'whenNeeded':\n          if (rowsPerPage >= data.totalCount) {\n            setShowPagination(false);\n          } else {\n            setShowPagination(true);\n          }\n\n          break;\n\n        default:\n        case 'always':\n          setShowPagination(true);\n          break;\n      }\n    }\n  }, [data, rowsPerPage]);\n  useEffect(() => {\n    let amount = 0;\n\n    if (hasToolbar) {\n      amount += toolbarRef.current.clientHeight;\n    }\n\n    if (showPagination) {\n      amount += paginationRef.current.clientHeight;\n    }\n\n    let style;\n\n    if (amount > 0 || !hasToolbar) {\n      style = {\n        height: `calc(100% - ${amount}px)`,\n        borderRadius: `${hasToolbar ? '0rem' : '0.1875rem'}`\n      };\n      setStylesProps({\n        style\n      });\n    } else {\n      setStylesProps(null);\n    }\n  }, [showPagination, hasToolbar]);\n  return <div className={classes.root}>\n\t\t\t\t<Paper classes={{\n      root: classes.paper\n    }} square={square} variant={variant} elevation={elevationLevel}>\n\t\t\t\t\t{hasToolbar && <Toolbar ref={toolbarRef} classes={{\n        root: classes.toolbar\n      }}>\n\t\t\t\t\t\t\t{titleText && <span className={classes.title}>{titleText}</span>}\n\t\t\t\t\t\t\t{searchProperty && !hideSearch && <TextField classes={{\n          root: classes.searchField\n        }} placeholder={`${useText(labelSearchOn)} ${searchPropertyLabel}`} InputProps={{\n          startAdornment: <InputAdornment position='start'>\n\t\t\t\t\t\t\t\t\t\t\t\t<Search />\n\t\t\t\t\t\t\t\t\t\t\t</InputAdornment>\n        }} onChange={handleSearch} />}\n\t\t\t\t\t\t</Toolbar>}\n\t\t\t\t\t<TableContainer ref={tableContainerRef} classes={{\n        root: classes.container\n      }} {...stylesProps}>\n\t\t\t\t\t\t<Table stickyHeader={stickyHeader} size={size} classes={{\n          root: classes.tableRoot\n        }}>\n\t\t\t\t\t\t\t<TableHead>\n\t\t\t\t\t\t\t\t<TableRow classes={{\n              root: classes.headerRow\n            }}>\n\t\t\t\t\t\t\t\t\t{renderTableHead()}\n\t\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t<TableBody ref={tableRef}>{renderTableContent()}</TableBody>\n\t\t\t\t\t\t\t{isDev && <TableBody ref={repeaterRef} className={classes.autoRepeat} />}\n\t\t\t\t\t\t</Table>\n\t\t\t\t\t</TableContainer>\n\t\t\t\t\t{showPagination && <TablePagination ref={paginationRef} classes={{\n        root: classes.pagination\n      }} rowsPerPageOptions={[5, 10, 25, 50, 100]} labelRowsPerPage={useText(labelRowsPerPage)} labelDisplayedRows={({\n        from,\n        to,\n        count\n      }) => `${from}-${to} ${useText(labelNumberOfPages)} ${count}`} component='div' count={model ? totalCount : takeNum} rowsPerPage={model ? rowsPerPage : takeNum} page={page} onChangePage={handleChangePage} onChangeRowsPerPage={handleChangeRowsPerPage} />}\n\t\t\t\t</Paper>\n\t\t\t</div>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    root: {\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      height: ({\n        options: {\n          height\n        }\n      }) => height\n    },\n    paper: {\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      height: '100%'\n    },\n    container: {\n      height: '100%'\n    },\n    tableRoot: {\n      tableLayout: 'fixed'\n    },\n    toolbar: {\n      paddingLeft: ['1rem', '!important'],\n      paddingRight: ['1rem', '!important']\n    },\n    title: {\n      color: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontColor(titleType),\n      fontFamily: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontFamily(titleType),\n      fontSize: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontSize(titleType),\n      fontWeight: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontWeight(titleType),\n      textTransform: ({\n        options: {\n          titleType\n        }\n      }) => style.getTextTransform(titleType),\n      letterSpacing: ({\n        options: {\n          titleType\n        }\n      }) => style.getLetterSpacing(titleType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Desktop')\n      }\n    },\n    headerRow: {\n      backgroundColor: ({\n        options: {\n          backgroundHeader\n        }\n      }) => [style.getColor(backgroundHeader), '!important'],\n      '& div': {\n        borderBottom: `${isDev ? '0.0625rem solid #cccccc' : 0}`\n      },\n      '& th, & div[role=\"columnheader\"]': {\n        borderBottom: `${isDev ? 0 : '0.0625rem solid #cccccc!important'}`,\n        backgroundColor: ({\n          options: {\n            backgroundHeader\n          }\n        }) => [style.getColor(backgroundHeader), '!important']\n      }\n    },\n    bodyRow: {\n      cursor: ({\n        options: {\n          linkTo\n        }\n      }) => linkTo && linkTo.id !== '' && 'pointer',\n      '&:hover td': {\n        backgroundColor: ({\n          options: {\n            linkTo,\n            backgroundRowHover\n          }\n        }) => linkTo && [style.getColor(backgroundRowHover), '!important']\n      }\n    },\n    searchField: {\n      marginLeft: ['auto', '!important'],\n      pointerEvents: isDev && 'none'\n    },\n    pagination: {\n      borderRadius: '0.1875rem',\n      pointerEvents: isDev && 'none',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important']\n    },\n    autoRepeat: {\n      opacity: 0.5\n    },\n    skeleton: {\n      height: `calc(${style.getFont('Body1').Mobile} * 1.2)`,\n      [`@media ${mediaMinWidth(600)}`]: {\n        height: `calc(${style.getFont('Body1').Portrait} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        height: `calc(${style.getFont('Body1').Landscape} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        height: `calc(${style.getFont('Body1').Desktop} * 1.2)`\n      },\n      backgroundColor: '#eee',\n      borderRadius: 8,\n      overflow: 'hidden',\n      '&::after': {\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        backgroundImage: 'linear-gradient(90deg, #eee 25%, #fff 50%, #eee 75%)',\n        backgroundSize: '200% 100%',\n        backgroundRepeat: 'no-repeat',\n        backgroundPositionX: '150%',\n        borderRadius: `calc(${style.getFont('Body2').Landscape} / 2)`,\n        content: '\"\"',\n        animation: 'loading 1.5s infinite'\n      }\n    },\n    '@keyframes loading': {\n      to: {\n        backgroundPositionX: '-150%'\n      }\n    },\n    [`@media ${mediaMinWidth(600)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Portrait'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Portrait'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Portrait'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Portrait')\n      }\n    },\n    [`@media ${mediaMinWidth(960)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Landscape'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Landscape'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Landscape'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Landscape')\n      }\n    },\n    [`@media ${mediaMinWidth(1280)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Desktop'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Desktop'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Desktop'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Desktop')\n      }\n    }\n  };\n}","functions":["updateFilter","Refetch","SetSearchValue"],"triggers":["onSuccess","onNoResults","onError","onLoad","OnRowClick"]},{"name":"DataTableColumn","type":"DATATABLE_COLUMN","allowedTypes":["CONTENT_COMPONENT","CONTAINER_COMPONENT"],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    env,\n    getProperty,\n    Property,\n    useEndpoint,\n    useText\n  } = B;\n  const {\n    TableCell,\n    TableSortLabel\n  } = window.MaterialUI.Core;\n  const {\n    horizontalAlignment,\n    headerText,\n    property,\n    content,\n    sortable\n  } = options;\n  const {\n    headerOnly,\n    handleSort,\n    orderBy,\n    linkTo,\n    handleRowClick,\n    context\n  } = parent || {};\n  const {\n    type\n  } = property;\n  const propertyArray = [property].flat();\n  const {\n    name: propertyName,\n    label: propertyLabel\n  } = getProperty(property) || {};\n  const {\n    field,\n    order = 'asc'\n  } = orderBy || {};\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const contentPlaceholder = isDev && isEmpty ? 'Select property' : '\\u00A0';\n  let myEndpoint = null;\n\n  if (linkTo) {\n    myEndpoint = useEndpoint(linkTo);\n  }\n\n  const bodyText = useText(content);\n  const propContent = isDev ? `{{ ${propertyName} }}` : <Property id={property} />;\n  let columnText = propertyName ? propContent : contentPlaceholder;\n\n  if (type === 'ME_PROPERTY') {\n    columnText = isDev ? `{{ ${propertyName} }}` : useText([property]);\n  }\n\n  if (bodyText) {\n    columnText = bodyText;\n  }\n\n  const header = useText(headerText);\n  let columnHeaderText = propertyLabel || contentPlaceholder;\n\n  if (header) {\n    columnHeaderText = header;\n  }\n\n  const isSortable = propertyName && sortable;\n\n  const createSortHandler = prop => {\n    const sortOrder = order === 'asc' ? 'desc' : 'asc';\n    handleSort(prop, sortOrder);\n  };\n\n  const isFilterSelected = fields => {\n    if (!fields || fields.length !== propertyArray.length) return false;\n\n    for (let index = 0; index < fields.length; index += 1) {\n      if (fields[index] !== propertyArray[index]) return false;\n    }\n\n    return true;\n  };\n\n  const Content = children.length > 0 ? children : <span className={classes.content}>{columnText}</span>;\n  const Header = isSortable ? <TableSortLabel classes={{\n    root: classes.columnSort\n  }} active={isFilterSelected(field)} direction={isFilterSelected(field) && order ? order : 'asc'} onClick={() => createSortHandler(propertyArray)}>\n\t\t\t\t<span className={classes.columnHeader}>{columnHeaderText}</span>\n\t\t\t</TableSortLabel> : <span className={classes.columnHeader}>{columnHeaderText}</span>;\n  const [visible, setVisible] = useState(false);\n  useEffect(() => {\n    setVisible(options.visible);\n  }, []);\n  B.defineFunction('Hide', () => setVisible(false));\n  B.defineFunction('Show', () => setVisible(true));\n  B.defineFunction('Show/Hide', () => setVisible(s => !s));\n\n  if (isDev) {\n    return <div className={[classes.tableColumn, !headerOnly ? classes.tableColumnBody : '', !headerOnly ? 'MuiTableCell-root' : ''].join(' ')}>\n\t\t\t\t\t{headerOnly ? <TableCell align={horizontalAlignment} component='div'>\n\t\t\t\t\t\t\t{Header}\n\t\t\t\t\t\t</TableCell> : Content}\n\t\t\t\t</div>;\n  }\n\n  return visible ? <TableCell classes={{\n    root: classes.root\n  }} align={horizontalAlignment} onClick={() => handleRowClick && handleRowClick(myEndpoint, context)}>\n\t\t\t\t{headerOnly ? Header : Content}\n\t\t\t</TableCell> : <></>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n  return {\n    tableColumn: {\n      display: 'table-cell',\n      verticalAlign: 'middle',\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      '& > div': {\n        display: 'block'\n      }\n    },\n    tableColumnBody: {\n      textAlign: ({\n        options: {\n          horizontalAlignment\n        }\n      }) => [horizontalAlignment, '!important'],\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    root: {\n      display: isDev && ['block', '!important'],\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    columnHeader: {\n      color: ({\n        options: {\n          type\n        }\n      }) => style.getFontColor(type),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Desktop')\n      }\n    },\n    content: {\n      color: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontColor(bodyType),\n      fontFamily: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontFamily(bodyType),\n      fontSize: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontSize(bodyType),\n      fontWeight: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontWeight(bodyType),\n      textTransform: ({\n        options: {\n          bodyType\n        }\n      }) => style.getTextTransform(bodyType),\n      letterSpacing: ({\n        options: {\n          bodyType\n        }\n      }) => style.getLetterSpacing(bodyType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Desktop')\n      }\n    },\n    columnSort: {\n      pointerEvents: isDev && 'none',\n      '& .MuiSvgIcon-root': {\n        opacity: isDev && 0.5\n      }\n    }\n  };\n}","functions":["Hide","Show","Show/Hide"],"triggers":[]},{"name":"DateTimePicker","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    useAsFilter,\n    filterBy,\n    filterType,\n    disabled,\n    error,\n    placeholder,\n    variant,\n    inputvariant,\n    type,\n    dateFormat,\n    timeFormat,\n    dateTimeFormat,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    disableToolbar,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    use24HourClockDateTime,\n    use24HourClockTime,\n    nameAttribute,\n    locale\n  } = options;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText,\n    useFilter,\n    getProperty\n  } = B;\n  const {\n    MuiPickersUtilsProvider,\n    KeyboardTimePicker,\n    KeyboardDatePicker,\n    KeyboardDateTimePicker\n  } = window.MaterialUI.Pickers;\n  const {\n    DateFnsUtils\n  } = window.MaterialUI;\n  const {\n    nlLocale,\n    enLocale\n  } = window.MaterialUI.DateLocales;\n  const {\n    AccessTime,\n    Event\n  } = window.MaterialUI.Icons;\n  const DateFns = new DateFnsUtils();\n  const isDev = env === 'dev';\n  const [selectedDate, setSelectedDate] = useState(null);\n  const helper = useText(helperText);\n  const placeholderText = useText(placeholder);\n  const rawFilterBy = useFilter(filterBy);\n  const filterProp = Object.keys(filterBy);\n  const filterPropType = isDev ? null : getProperty(filterProp[0]).kind;\n  const localeMap = {\n    nl: nlLocale,\n    en: enLocale\n  };\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const strDefaultValue = useText(defaultValue);\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n\n  const isValidDate = date => date instanceof Date && !isNaN(date);\n\n  const toJSONLocal = date => {\n    var local = new Date(date);\n    local.setMinutes(date.getMinutes() - date.getTimezoneOffset());\n    return local.toJSON().slice(0, 10);\n  };\n\n  const changeHandler = date => {\n    setSelectedDate(date);\n\n    if (useAsFilter) {\n      if (date !== null && date.toString() !== 'Invalid Date') {\n        const value = getDeepestObject(rawFilterBy);\n        const parsedDate = filterPropType === 'date' ? toJSONLocal(date) : date.toISOString();\n        setDeepestKey(rawFilterBy, value, parsedDate);\n        B.triggerEvent('sendFilter', {\n          filter: rawFilterBy,\n          label: labelText\n        });\n      } else {\n        B.triggerEvent('sendFilter', {\n          filter: undefined,\n          label: labelText\n        });\n      }\n    }\n  };\n\n  const getDeepestObject = obj => {\n    if (typeof obj[Object.keys(obj)] === 'object') {\n      return getDeepestObject(obj[Object.keys(obj)]);\n    }\n\n    return obj;\n  };\n\n  const setDeepestKey = (obj, value, newCurrentValue) => {\n    if (Object.values(obj).includes(value)) {\n      const key = Object.keys(obj);\n      return obj[key] = {\n        [filterType]: newCurrentValue\n      };\n    }\n\n    return setDeepestKey(obj[Object.keys(obj)], value, newCurrentValue);\n  };\n\n  const setDefaultDate = (defaultFormat, givenFormat) => {\n    if (!selectedDate && strDefaultValue) {\n      const propDefaultParse = defaultFormat ? DateFns.parse(strDefaultValue, defaultFormat) : new Date(strDefaultValue);\n      const formatDefaultParse = DateFns.parse(strDefaultValue, givenFormat);\n\n      if (isValidDate(propDefaultParse)) {\n        setSelectedDate(propDefaultParse);\n      } else if (isValidDate(formatDefaultParse)) {\n        setSelectedDate(formatDefaultParse);\n      } else {\n        setSelectedDate(DateFns.parse('00:00:00', 'HH:mm:ss'));\n      }\n    }\n  };\n\n  B.defineFunction('Clear', () => setSelectedDate(null));\n  let DateTimeComponent;\n  let format;\n  let resultString;\n  let use24HourClock = true;\n\n  switch (type) {\n    case 'date':\n      {\n        DateTimeComponent = KeyboardDatePicker;\n        format = dateFormat || 'dd/MM/yyyy';\n        setDefaultDate('yyyy-MM-dd', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'yyyy-MM-dd') : null;\n        break;\n      }\n\n    case 'datetime':\n      {\n        DateTimeComponent = KeyboardDateTimePicker;\n        format = dateTimeFormat || 'dd/MM/yyyy HH:mm:ss';\n        use24HourClock = use24HourClockDateTime;\n        setDefaultDate(null, format);\n        resultString = isValidDate(selectedDate) ? new Date(selectedDate).toISOString() : new Date().toISOString();\n        break;\n      }\n\n    case 'time':\n      {\n        DateTimeComponent = KeyboardTimePicker;\n        format = timeFormat || 'HH:mm:ss';\n        use24HourClock = use24HourClockTime;\n        setDefaultDate('HH:mm:ss', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'HH:mm:ss') : null;\n        break;\n      }\n\n    default:\n  }\n\n  const DateTimeCmp = <DateTimeComponent name={nameAttributeValue || customModelAttributeName} value={selectedDate} size={size} classes={{\n    root: classes.formControl\n  }} variant={variant} placeholder={placeholderText} fullWidth={fullWidth} onChange={changeHandler} inputVariant={inputvariant} InputProps={{\n    inputProps: {\n      name: nameAttributeValue || customModelAttributeName,\n      tabIndex: isDev && -1\n    }\n  }} KeyboardButtonProps={{\n    tabIndex: isDev && -1\n  }} required={required} disabled={disabled} label={!hideLabel && labelText} error={error} margin={margin} helperText={helper} disableToolbar={disableToolbar} format={format} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} DialogProps={{\n    className: classes.dialog\n  }} ampm={!use24HourClock} keyboardIcon={type === 'time' ? <AccessTime /> : <Event />} />;\n  return isDev ? <div className={classes.root}>\n\t\t\t\t<MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t\t</MuiPickersUtilsProvider>\n\t\t\t</div> : <MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t<input type='hidden' name={nameAttributeValue || customModelAttributeName} value={resultString} />\n\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t</MuiPickersUtilsProvider>;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    dialog: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      },\n      '& .MuiButton-textPrimary': {\n        color: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    popover: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            inputvariant\n          }\n        }) => inputvariant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    },\n    static: {\n      '& .MuiPickersStaticWrapper-staticWrapperRoot': {\n        '& .MuiToolbar-root, & .MuiPickersDay-daySelected': {\n          backgroundColor: ({\n            options: {\n              backgroundColorPopup\n            }\n          }) => [style.getColor(backgroundColorPopup), '!important']\n        }\n      }\n    }\n  };\n}","functions":["Clear"],"triggers":["sendFilter","sendFilter"]},{"name":"AutoComplete","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    useAsFilter,\n    filterBy,\n    filterType,\n    disabled,\n    error,\n    placeholder,\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    model,\n    multiple,\n    freeSolo,\n    searchProperty,\n    valueProperty,\n    closeOnSelect,\n    renderCheckboxes,\n    showError,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    property,\n    nameAttribute,\n    order,\n    orderBy\n  } = options;\n  const {\n    Autocomplete\n  } = window.MaterialUI.Lab;\n  const {\n    TextField,\n    CircularProgress,\n    Chip,\n    Checkbox\n  } = window.MaterialUI.Core;\n  const {\n    ExpandMore,\n    Close,\n    CheckBox,\n    CheckBoxOutlineBlank\n  } = window.MaterialUI.Icons;\n  const {\n    useText,\n    getProperty,\n    getCustomModelAttribute,\n    useAllQuery,\n    env\n  } = B;\n  const isDev = env === 'dev';\n  const displayError = showError === 'built-in';\n  const placeholderText = useText(placeholder);\n  const helper = useText(helperText);\n  const nameAttributeValue = useText(nameAttribute);\n  const rawFilterBy = B.useFilter(filterBy);\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const {\n    kind,\n    values: listValues\n  } = getProperty(property) || {};\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const [currentLabel, setCurrentLabel] = useState('');\n  const labelText = useText(label);\n  const textFieldProps = {\n    disabled,\n    variant,\n    label: !hideLabel && labelText,\n    fullWidth,\n    size,\n    type,\n    required,\n    error,\n    placeholder: placeholderText,\n    margin,\n    helperText: helper,\n    classes: {\n      root: classes.formControl\n    }\n  };\n  const searchProp = getProperty(searchProperty) || {};\n  const valueProp = getProperty(valueProperty) || {};\n  const [searchParam, setSearchParam] = useState('');\n  const [debouncedSearchParam, setDebouncedSearchParam] = useState('');\n  const {\n    filter\n  } = options;\n  const hasSearch = searchProp && searchProp.id;\n  const hasValue = valueProp && valueProp.id;\n\n  if (hasSearch && debouncedSearchParam !== '') {\n    filter[searchProp.id] = {\n      regex: debouncedSearchParam\n    };\n  } else if (hasSearch && debouncedSearchParam === '') {\n    delete filter[searchProp.id];\n  }\n\n  const hasNoProp = !hasSearch || !hasValue;\n  const reason = hasNoProp ? 'No property selected' : 'No data';\n  let inputProps = {\n    inputProps: {\n      tabIndex: isDev && -1\n    },\n    endAdornment: <>\n\t\t\t\t\t{currentValue && <Close />}\n\t\t\t\t\t{!freeSolo && <ExpandMore />}\n\t\t\t\t</>\n  };\n\n  if (multiple && currentValue) {\n    inputProps = { ...inputProps,\n      startAdornment: <Chip label={currentValue} onDelete={() => {}} />\n    };\n  }\n\n  const valueArray = currentValue ? currentValue.toString().split(',') : [];\n  const rawFilter = {\n    rawFilter: {\n      [valueProp.name]: {\n        in: valueArray\n      }\n    }\n  };\n  const [useFilter, setUseFilter] = useState(currentValue ? rawFilter : filter);\n\n  const resetFilter = () => {\n    setUseFilter({\n      filter\n    });\n  };\n\n  const orderByArray = [orderBy].flat();\n  const sort = !isDev && orderBy ? orderByArray.reduceRight((acc, orderByProperty, index) => {\n    const prop = getProperty(orderByProperty);\n    return index === orderByArray.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const {\n    loading,\n    error: err,\n    data,\n    refetch\n  } = model && useAllQuery(model, { ...useFilter,\n    skip: 0,\n    take: 50,\n    variables: { ...(orderBy ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    }\n  });\n  useEffect(() => {\n    if (!isDev && data) {\n      resetFilter();\n    }\n  }, [data]);\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n    }\n  }, [isDev, defaultValue]);\n  B.defineFunction('Clear', () => setCurrentValue(null));\n  B.defineFunction('Refetch', () => refetch());\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedSearchParam(searchParam);\n    }, 1000);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchParam]);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  if (err && !displayError) {\n    B.triggerEvent('onError', err);\n  }\n\n  const {\n    results\n  } = data || {};\n\n  if (results) {\n    if (results.length > 0) {\n      B.triggerEvent('onSuccess', results);\n    } else {\n      B.triggerEvent('onNoResults');\n    }\n  }\n\n  const onChange = (_, newValue) => {\n    if (!valueProp || !newValue) {\n      setCurrentValue(newValue);\n      setCurrentLabel(newValue);\n      B.triggerEvent('OnChange', newValue);\n      B.triggerEvent('sendFilter', {\n        filter: undefined,\n        label: labelText\n      });\n      return;\n    }\n\n    let newCurrentValue = newValue[valueProp.name] || newValue;\n\n    if (typeof newValue === 'string') {\n      if (currentLabel === newValue) {\n        newCurrentValue = currentValue;\n      }\n    } else if (searchProp) {\n      const newLabelValue = newValue[searchProp.name];\n      setCurrentLabel(newLabelValue);\n    }\n\n    if (multiple) {\n      newCurrentValue = newValue.map(rec => rec[valueProp.name] || rec);\n    }\n\n    setCurrentValue(newCurrentValue);\n    B.triggerEvent('OnChange', newCurrentValue);\n\n    if (useAsFilter) {\n      if (multiple && newCurrentValue.length > 0 || !multiple) {\n        const value = getDeepestObject(rawFilterBy);\n        setDeepestKey(rawFilterBy, value, newCurrentValue);\n        B.triggerEvent('sendFilter', {\n          filter: rawFilterBy,\n          label: labelText\n        });\n      } else {\n        B.triggerEvent('sendFilter', {\n          filter: undefined,\n          label: labelText\n        });\n      }\n    }\n  };\n\n  const getDeepestObject = obj => {\n    if (typeof obj[Object.keys(obj)] === 'object') {\n      return getDeepestObject(obj[Object.keys(obj)]);\n    }\n\n    return obj;\n  };\n\n  const setDeepestKey = (obj, value, newCurrentValue) => {\n    if (Object.values(obj).includes(value)) {\n      const key = Object.keys(obj);\n      return obj[key] = {\n        [filterType]: newCurrentValue\n      };\n    }\n\n    return setDeepestKey(obj[Object.keys(obj)], value, newCurrentValue);\n  };\n\n  const getDefaultValue = React.useCallback(() => {\n    if (!currentValue || !results) {\n      return multiple ? [] : null;\n    }\n\n    let currentRecordsKeys = currentValue;\n\n    if (!Array.isArray(currentValue)) {\n      currentRecordsKeys = multiple ? currentValue.toString().split(',') : [currentValue];\n    }\n\n    const currentRecords = results.reduce((acc, cv) => {\n      const searchStr = cv[valueProp.name].toString();\n      const search = cv[valueProp.name];\n\n      if (currentRecordsKeys.indexOf(searchStr) > -1 || currentRecordsKeys.indexOf(search) > -1) {\n        acc.push(cv);\n      }\n\n      return acc;\n    }, []);\n    const singleRecord = currentRecords[0] ? { ...currentRecords[0]\n    } : null;\n    return multiple ? currentRecords : singleRecord;\n  }, [results]);\n  const defaultRecord = getDefaultValue();\n  useEffect(() => {\n    if (!multiple && defaultRecord && searchProp) {\n      setCurrentLabel(defaultRecord[searchProp.name]);\n    }\n  }, [defaultRecord]);\n\n  const renderLabel = option => {\n    const optionLabel = option[searchProp.name];\n    return optionLabel !== undefined && optionLabel === '' ? '-- empty --' : optionLabel && optionLabel.toString() || option;\n  };\n\n  const renderOption = (option, {\n    selected\n  }) => <>\n\t\t\t\t<Checkbox classes={{\n      root: classes.checkbox\n    }} icon={<CheckBoxOutlineBlank fontSize='small' />} checkedIcon={<CheckBox fontSize='small' />} style={{\n      marginRight: 8\n    }} checked={selected} />\n\t\t\t\t{renderLabel(option)}\n\t\t\t</>;\n\n  if (isDev) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (kind === 'list' || kind === 'LIST') {\n    const onPropertyListChange = (_, newValue) => {\n      setCurrentValue(newValue);\n      B.triggerEvent('OnChange');\n    };\n\n    const selectValues = listValues.map(({\n      value\n    }) => value).filter(e => e.startsWith(searchParam)) || [];\n    return <Autocomplete id='combo-box-demo' options={selectValues} value={currentValue} PopoverProps={{\n      classes: {\n        root: classes.popover\n      }\n    }} onInputChange={(_, inputValue) => {\n      setSearchParam(inputValue);\n    }} onChange={onPropertyListChange} getOptionLabel={option => option} renderInput={params => <TextField {...params} {...textFieldProps} name={nameAttributeValue || customModelAttributeName} key={currentValue ? 'hasValue' : 'isEmpty'} required={required && !currentValue} InputProps={{ ...params.InputProps,\n      endAdornment: params.InputProps.endAdornment\n    }} />} />;\n  }\n\n  if (!model) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (err && displayError) return <span>{err.message}</span>;\n\n  if (!data || hasNoProp) {\n    return <TextField {...textFieldProps} defaultValue={reason} disabled InputProps={{\n      endAdornment: <CircularProgress color='inherit' size={20} />\n    }} />;\n  }\n\n  return <Autocomplete multiple={multiple} freeSolo={freeSolo} autoSelect={freeSolo} options={results} defaultValue={defaultRecord} getOptionLabel={renderLabel} getOptionSelected={(option, value) => value.id === option.id} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} onInputChange={(_, inputValue) => {\n    if (!freeSolo) {\n      return;\n    }\n\n    setSearchParam(inputValue);\n  }} onChange={onChange} disableCloseOnSelect={!closeOnSelect} renderOption={renderCheckboxes && renderOption} renderInput={params => <>\n\t\t\t\t\t\t<input type='hidden' key={currentValue ? 'hasValue' : 'isEmpty'} name={nameAttributeValue || customModelAttributeName} value={currentValue} />\n\t\t\t\t\t\t<TextField {...params} {...textFieldProps} required={required && (!currentValue || currentValue.length === 0)} loading={loading} InputProps={{ ...params.InputProps,\n      endAdornment: <>\n\t\t\t\t\t\t\t\t\t\t{loading ? <CircularProgress color='inherit' size={20} /> : null}\n\t\t\t\t\t\t\t\t\t\t{params.InputProps.endAdornment}\n\t\t\t\t\t\t\t\t\t</>\n    }} />\n\t\t\t\t\t</>} />;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  const {\n    color: colorFunc\n  } = B;\n\n  const getOpacColor = (col, val) => colorFunc.alpha(col, val);\n\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    checkbox: {\n      color: ({\n        options: {\n          checkboxColor\n        }\n      }) => [style.getColor(checkboxColor), '!important'],\n      '&.MuiCheckbox-root.Mui-checked:hover, &.MuiIconButton-root:hover': {\n        backgroundColor: ({\n          options: {\n            checkboxColor\n          }\n        }) => [getOpacColor(style.getColor(checkboxColor), 0.04), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            variant\n          }\n        }) => variant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        },\n        '& .MuiChip-root': {\n          color: ({\n            options: {\n              textColorChip\n            }\n          }) => [style.getColor(textColorChip), '!important'],\n          backgroundColor: ({\n            options: {\n              backgroundColorChip\n            }\n          }) => [style.getColor(backgroundColorChip), '!important']\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Refetch"],"triggers":["onLoad","onError","onSuccess","onNoResults","OnChange","sendFilter","OnChange","sendFilter","sendFilter","OnChange"]}]
