[{"name":"AppBar","type":"BODY_COMPONENT","allowedTypes":["CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    AppBar,\n    Toolbar,\n    IconButton,\n    Typography,\n    Menu\n  } = window.MaterialUI.Core;\n  const {\n    Menu: MenuIcon\n  } = window.MaterialUI.Icons;\n  const {\n    position,\n    title,\n    logoSource,\n    endpoint,\n    appBarVariant,\n    toolbarVariant,\n    square,\n    elevation\n  } = options;\n  const {\n    Link,\n    env,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const [anchorEl, setAnchorEl] = useState(null);\n  const open = !!anchorEl;\n  const titleText = useText(title);\n\n  const handleMenu = event => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const logo = useText(logoSource);\n  const LogoCmp = logo && <img src={logo} className={classes.logo} alt='' />;\n  const LogoComponent = endpoint.id ? // eslint-disable-next-line jsx-a11y/anchor-is-valid\n  <Link endpoint={endpoint}>{LogoCmp}</Link> : LogoCmp;\n  const AppBarComponent = <AppBar position={isDev ? 'static' : position} classes={{\n    root: classes.root\n  }} variant={appBarVariant} square={square} elevation={appBarVariant === 'flat' ? 0 : elevation}>\n        <Toolbar variant={toolbarVariant} classes={{\n      root: classes.toolbar\n    }}>\n          {logo.length > 0 && LogoComponent}\n          <Typography variant='h6' noWrap className={classes.title} component={endpoint.id && Link} endpoint={endpoint.id && endpoint}>\n            {titleText}\n          </Typography>\n          <div className={classes.spacer} />\n          {!isDev && !!children.length ? <>\n              <div className={classes.collapsed}>\n                <IconButton color='inherit' onClick={handleMenu}>\n                  <MenuIcon />\n                </IconButton>\n                <Menu anchorEl={anchorEl} open={open} keepMounted onClose={handleClose} classes={{\n            paper: classes.root,\n            list: classes.list\n          }}>\n                  {children}\n                </Menu>\n              </div>\n              <div className={classes.uncollapsed}>{children}</div>\n            </> : <div>{children}</div>}\n        </Toolbar>\n      </AppBar>;\n  return isDev ? <div>{AppBarComponent}</div> : AppBarComponent;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      height: ({\n        options: {\n          height\n        }\n      }) => height,\n      backgroundColor: ({\n        options: {\n          backgroundColor\n        }\n      }) => [style.getColor(backgroundColor), '!important'],\n      color: ({\n        options: {\n          color\n        }\n      }) => [style.getColor(color), '!important'],\n      zIndex: '1201 !important'\n    },\n    logo: {\n      width: ({\n        options: {\n          logoWidth\n        }\n      }) => logoWidth\n    },\n    toolbar: {\n      flexDirection: ({\n        options: {\n          alignItems\n        }\n      }) => alignItems === 'right' ? 'row' : 'row-reverse'\n    },\n    menuButton: {\n      marginLeft: style.getSpacing('M'),\n      marginRight: style.getSpacing('M')\n    },\n    title: {\n      textDecoration: 'none',\n      color: ({\n        options: {\n          color\n        }\n      }) => [style.getColor(color), '!important']\n    },\n    spacer: {\n      flexGrow: 1\n    },\n    list: {\n      '& > *': {\n        display: 'block'\n      }\n    },\n    collapsed: {\n      display: 'block',\n      [`@media ${B.mediaMinWidth(600)}`]: {\n        display: 'none'\n      }\n    },\n    uncollapsed: {\n      display: 'none',\n      [`@media ${B.mediaMinWidth(600)}`]: {\n        display: 'block'\n      }\n    }\n  };\n}","functions":[],"triggers":[]},{"name":"Button","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    Button,\n    IconButton,\n    CircularProgress\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    variant,\n    disabled,\n    fullWidth,\n    size,\n    icon,\n    iconPosition,\n    linkType,\n    linkTo,\n    linkToExternal,\n    type,\n    visible,\n    actionId,\n    buttonText,\n    actionProperties\n  } = options;\n  const {\n    env,\n    useText,\n    useAction\n  } = B;\n  const isDev = env === 'dev';\n  const isAction = linkType === 'action';\n  const hasLink = linkTo && linkTo.id !== '';\n  const hasExternalLink = linkToExternal && linkToExternal.id !== '';\n  const linkToExternalVariable = linkToExternal && useText(linkToExternal) || '';\n  const isIcon = variant === 'icon';\n  const buttonContent = useText(buttonText);\n  const [isVisible, setIsVisible] = useState(visible);\n  const [isLoading, setIsLoading] = useState(false);\n  const propertyMappings = new Map(actionProperties);\n  const input = Array.from(propertyMappings.keys()).reduce((acc, key) => {\n    const propertyId = propertyMappings.get(key);\n    const value = isDev ? '' : B.useProperty(propertyId);\n    acc[key] = value;\n    return acc;\n  }, {});\n  const [actionCallback, {\n    loading\n  }] = isAction && useAction(actionId, {\n    variables: {\n      input\n    },\n\n    onCompleted(data) {\n      B.triggerEvent('onActionSuccess', data.actionb5);\n    },\n\n    onError(error) {\n      B.triggerEvent('onActionError', error);\n    }\n\n  }) || [() => {}, {\n    loading: false\n  }];\n  useEffect(() => {\n    setIsVisible(visible);\n  }, [visible]);\n  B.defineFunction('Show', () => setIsVisible(true));\n  B.defineFunction('Hide', () => setIsVisible(false));\n  B.defineFunction('Show/Hide', () => setIsVisible(s => !s));\n  B.defineFunction('Toggle loading state', () => setIsLoading(s => !s));\n  useEffect(() => {\n    if (loading) {\n      B.triggerEvent('onActionLoad', loading);\n    }\n  }, [loading]);\n  const generalProps = {\n    disabled: disabled || isLoading || loading,\n    size,\n    tabindex: isDev && -1,\n    href: linkType === 'external' && hasExternalLink ? linkToExternalVariable : undefined,\n    component: linkType === 'internal' && hasLink ? B.Link : undefined,\n    endpoint: linkType === 'internal' && hasLink ? linkTo : undefined\n  };\n  const iconButtonProps = { ...generalProps,\n    classes: {\n      root: classes.root\n    }\n  };\n  const buttonProps = { ...generalProps,\n    fullWidth,\n    variant,\n    classes: {\n      root: classes.root,\n      contained: classes.contained,\n      outlined: classes.outlined\n    },\n    className: !!buttonContent && classes.empty,\n    type: isDev ? 'button' : type\n  };\n  const compProps = isIcon ? iconButtonProps : buttonProps;\n  const BtnComp = isIcon ? IconButton : Button;\n  const showIndicator = !isIcon && (isLoading || loading);\n  const ButtonComponent = <BtnComp {...compProps} startIcon={!isIcon && icon !== 'None' && iconPosition === 'start' && React.createElement(Icons[icon])} endIcon={!isIcon && icon !== 'None' && iconPosition === 'end' && React.createElement(Icons[icon])} onClick={event => {\n    event.stopPropagation();\n    actionCallback();\n  }}>\n        {isIcon && React.createElement(Icons[icon === 'None' ? 'Error' : icon], {\n      fontSize: size\n    })}\n        {!isIcon && buttonContent}\n        {showIndicator && <CircularProgress size={16} className={classes.loader} />}\n      </BtnComp>;\n\n  if (isDev) {\n    return <div className={classes.wrapper}>{ButtonComponent}</div>;\n  }\n\n  return isVisible ? ButtonComponent : <></>;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    wrapper: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      width: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth && '100%',\n      minHeight: '1rem',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    root: {\n      color: ({\n        options: {\n          background,\n          disabled,\n          textColor,\n          variant\n        }\n      }) => [!disabled ? style.getColor(variant === 'icon' ? background : textColor) : 'rgba(0, 0, 0, 0.26)', '!important'],\n      width: ({\n        options: {\n          fullWidth,\n          outerSpacing\n        }\n      }) => {\n        if (!fullWidth) return 'auto';\n        const marginRight = getSpacing(outerSpacing[1]);\n        const marginLeft = getSpacing(outerSpacing[3]);\n        return `calc(100% - ${marginRight} - ${marginLeft})`;\n      },\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      '&.MuiButton-root, &.MuiIconButton-root': {\n        [`@media ${B.mediaMinWidth(600)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Portrait');\n            const marginLeft = getSpacing(outerSpacing[3], 'Portrait');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Portrait'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Portrait'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Portrait'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Portrait')\n        },\n        [`@media ${B.mediaMinWidth(960)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Landscape');\n            const marginLeft = getSpacing(outerSpacing[3], 'Landscape');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Landscape'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Landscape'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Landscape'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Landscape')\n        },\n        [`@media ${B.mediaMinWidth(1280)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Desktop');\n            const marginLeft = getSpacing(outerSpacing[3], 'Desktop');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Desktop'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Desktop'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Desktop'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Desktop')\n        }\n      }\n    },\n    contained: {\n      backgroundColor: ({\n        options: {\n          background,\n          disabled\n        }\n      }) => [!disabled ? style.getColor(background) : 'rgba(0, 0, 0, 0.12)', '!important']\n    },\n    outlined: {\n      borderColor: ({\n        options: {\n          background,\n          disabled\n        }\n      }) => [!disabled ? style.getColor(background) : 'rgba(0, 0, 0, .12)', '!important']\n    },\n    loader: {\n      color: ({\n        options: {\n          variant,\n          textColor,\n          background\n        }\n      }) => [style.getColor(variant === 'icon' ? background : textColor), '!important'],\n      marginLeft: '0.25rem'\n    },\n    empty: {\n      '&::before': {\n        content: '\"\\xA0\"'\n      }\n    }\n  };\n}","functions":["Show","Hide","Show/Hide","Toggle loading state"],"triggers":["onActionSuccess","onActionError","onActionLoad"]},{"name":"DataTable","type":"CONTENT_COMPONENT","allowedTypes":["DATATABLE_COLUMN"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Children,\n    env,\n    getProperty,\n    GetMe,\n    InteractionScope,\n    ModelProvider,\n    useAllQuery,\n    useFilter,\n    useText\n  } = B;\n  const {\n    Table,\n    TableBody,\n    TableContainer,\n    TableHead,\n    TableRow,\n    TableCell,\n    TablePagination,\n    Paper,\n    Toolbar,\n    TextField,\n    InputAdornment\n  } = window.MaterialUI.Core;\n  const {\n    Search\n  } = window.MaterialUI.Icons;\n  const isDev = env === 'dev';\n  const {\n    take,\n    size,\n    model,\n    authProfile,\n    filter,\n    searchProperty,\n    hideSearch,\n    orderProperty,\n    sortOrder,\n    labelRowsPerPage,\n    labelNumberOfPages,\n    labelSearchOn,\n    square,\n    elevation,\n    variant,\n    stickyHeader,\n    title,\n    pagination,\n    linkTo,\n    showError,\n    autoLoadOnScroll,\n    autoLoadTakeAmount\n  } = options;\n  const repeaterRef = React.createRef();\n  const tableRef = React.createRef();\n  const tableContainerRef = React.createRef();\n  const displayError = showError === 'built-in';\n  const [page, setPage] = useState(0);\n  const takeNum = parseInt(take, 10);\n  const initialRender = useRef(true);\n  const skipAppend = useRef(false);\n  const [skip, setSkip] = useState(0);\n  const loadOnScroll = pagination === 'never' && autoLoadOnScroll;\n  const autoLoadTakeAmountNum = parseInt(autoLoadTakeAmount, 10);\n  const [rowsPerPage, setRowsPerPage] = useState(takeNum);\n  const [search, setSearch] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [showPagination, setShowPagination] = useState(false);\n  const {\n    label: searchPropertyLabel = '{property}'\n  } = getProperty(searchProperty) || {};\n  const [orderBy, setOrderBy] = React.useState({\n    field: [orderProperty].flat() || null,\n    order: orderProperty ? sortOrder : null\n  });\n  const [results, setResults] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n  const [previousSearchTerm, setPreviousSearchTerm] = useState('');\n  const [newSearch, setNewSearch] = useState(false);\n  const fetchingNextSet = useRef(false);\n  const [initialTimesFetched, setInitialTimesFetched] = useState(0);\n  const amountOfRows = loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage;\n  const [newFilter, setNewFilter] = useState({});\n\n  const createSortObject = (fields, order) => {\n    const fieldsArray = [fields].flat();\n    const sort = fieldsArray.reduceRight((acc, property, index) => {\n      const prop = getProperty(property);\n      return index === fieldsArray.length - 1 ? {\n        [prop.name]: order.toUpperCase()\n      } : {\n        [prop.name]: acc\n      };\n    }, {});\n    return sort;\n  };\n\n  const [variables, setVariables] = useState(orderProperty ? {\n    sort: {\n      relation: !isDev && createSortObject(orderProperty, sortOrder)\n    }\n  } : {});\n  const titleText = useText(title);\n  const hasToolbar = titleText || searchProperty && !hideSearch;\n  const elevationLevel = variant === 'flat' ? 0 : elevation;\n  const hasLink = linkTo && linkTo.id !== '';\n  const toolbarRef = React.createRef();\n  const paginationRef = React.createRef();\n  const [stylesProps, setStylesProps] = useState(null);\n\n  const deepMerge = (...objects) => {\n    const isObject = item => item && typeof item === 'object' && !Array.isArray(item);\n\n    return objects.reduce((accumulator, object) => {\n      Object.keys(object).forEach(key => {\n        const accumulatorValue = accumulator[key];\n        const value = object[key];\n\n        if (Array.isArray(accumulatorValue) && Array.isArray(value)) {\n          accumulator[key] = accumulatorValue.concat(value);\n        } else if (isObject(accumulatorValue) && isObject(value)) {\n          accumulator[key] = deepMerge(accumulatorValue, value);\n        } else {\n          accumulator[key] = value;\n        }\n      });\n      return accumulator;\n    }, {});\n  };\n\n  let path = [searchProperty].flat();\n\n  if (typeof searchProperty.id !== 'undefined') {\n    path = [searchProperty.id].flat();\n  }\n\n  const searchFilter = searchProperty ? path.reduceRight((acc, property, index) => index === path.length - 1 ? {\n    [property]: {\n      matches: searchTerm\n    }\n  } : {\n    [property]: acc\n  }, {}) : {};\n  B.defineFunction('updateFilter', updatedFilter => {\n    if (updatedFilter.filter != undefined) {\n      setNewFilter(prevFilter => ({ ...prevFilter,\n        [updatedFilter.label]: updatedFilter.filter\n      }));\n    } else {\n      const filterCopy = { ...newFilter\n      };\n      delete filterCopy[updatedFilter.label];\n      setNewFilter(filterCopy);\n    }\n  });\n  const where = { ...useFilter(filter),\n    ...(Object.values(newFilter).length > 0 ? {\n      _and: Object.values(newFilter)\n    } : {})\n  };\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = model && useAllQuery(model, {\n    rawFilter: where,\n    variables,\n    skip: loadOnScroll ? skip : page * rowsPerPage,\n    take: loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage\n  });\n  useEffect(() => {\n    if (!isDev && data) {\n      if (pagination !== 'never') {\n        setResults(data.results);\n        setTotalCount(data.totalCount);\n        return;\n      }\n\n      if (searchTerm !== previousSearchTerm) {\n        setSkip(0);\n        setInitialTimesFetched(0);\n        setPreviousSearchTerm(searchTerm);\n        setNewSearch(true);\n      } else {\n        if (newSearch || !autoLoadOnScroll && skipAppend.current) {\n          setResults(data.results);\n        } else {\n          setResults(prev => [...prev, ...data.results]);\n        }\n\n        fetchingNextSet.current = false;\n        setNewSearch(false);\n      }\n\n      skipAppend.current = false;\n      setTotalCount(data.totalCount);\n    }\n  }, [data, searchTerm]);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setSearchTerm(search);\n    }, 300);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [search]);\n\n  function clearResults() {\n    setInitialTimesFetched(0);\n    setResults([]);\n    setTimeout(() => {\n      setSkip(0);\n    }, 0);\n  }\n\n  B.defineFunction('Refetch', () => {\n    if (pagination === 'never') {\n      clearResults();\n      skipAppend.current = true;\n      setTimeout(() => {\n        refetch();\n      }, 0);\n    } else {\n      refetch();\n    }\n  });\n  B.defineFunction('SetSearchValue', event => {\n    setSearch(event.target.value);\n  });\n  useEffect(() => {\n    if (!isDev) return;\n\n    const repeat = () => {\n      if (!repeaterRef.current) return;\n\n      if (repeaterRef.current.previousElementSibling.children.length === 0) {\n        return;\n      }\n\n      repeaterRef.current.innerHTML = '';\n\n      for (let i = 0, j = amountOfRows - 1; i < j; i += 1) {\n        repeaterRef.current.innerHTML += repeaterRef.current.previousElementSibling.children[0].outerHTML;\n      }\n    };\n\n    const mutationObserver = new MutationObserver(() => {\n      repeat();\n    });\n    mutationObserver.observe(tableRef.current, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    repeat();\n  });\n  useEffect(() => {\n    setRowsPerPage(takeNum);\n  }, [takeNum]);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  if (error && !displayError) {\n    B.triggerEvent('onError', error);\n  }\n\n  if (results.length > 0) {\n    B.triggerEvent('onSuccess', results);\n  } else {\n    B.triggerEvent('onNoResults');\n  }\n\n  const handleChangePage = (_, newPage) => {\n    if (loading || error) return;\n    setPage(newPage);\n  };\n\n  const handleChangeRowsPerPage = event => {\n    if (loading || error) return;\n    setRowsPerPage(parseInt(event.target.value, 10));\n    setPage(0);\n  };\n\n  const handleSort = (field, newOrder) => {\n    if (isDev) return;\n    setOrderBy({\n      field,\n      order: newOrder\n    });\n    setVariables({\n      sort: {\n        relation: createSortObject(field, newOrder)\n      }\n    });\n  };\n\n  const handleSearch = event => {\n    setSearch(event.target.value);\n  };\n\n  const handleRowClick = (endpoint, context) => {\n    if (isDev) return;\n    B.triggerEvent('OnRowClick', endpoint, context);\n\n    if (hasLink) {\n      const history = useHistory();\n      history.push(endpoint);\n    }\n  };\n\n  const renderTableHead = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n\t\t\t\t\t\t<div className={classes.skeleton}>\n\t\t\t\t\t\t\t{error && displayError && error.message}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</TableCell>);\n    }\n\n    return <Children headerOnly handleSort={handleSort} orderBy={orderBy}>\n\t\t\t\t\t{children}\n\t\t\t\t</Children>;\n  };\n\n  const tableContentModel = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(rowsPerPage).keys()).map(idx => <TableRow key={idx} classes={{\n        root: classes.bodyRow\n      }}>\n\t\t\t\t\t\t{Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n\t\t\t\t\t\t\t\t<div className={classes.skeleton} />\n\t\t\t\t\t\t\t</TableCell>)}\n\t\t\t\t\t</TableRow>);\n    }\n\n    const rows = results.map(value => <ModelProvider value={value} id={model}>\n\t\t\t\t\t<InteractionScope model={model}>\n\t\t\t\t\t\t{context => <TableRow key={value[0]} classes={{\n          root: classes.bodyRow\n        }} data-id={value.id}>\n\t\t\t\t\t\t\t\t<Children linkTo={linkTo} handleRowClick={handleRowClick} context={context}>\n\t\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t\t</Children>\n\t\t\t\t\t\t\t</TableRow>}\n\t\t\t\t\t</InteractionScope>\n\t\t\t\t</ModelProvider>);\n\n    if (authProfile) {\n      return <GetMe authenticationProfileId={authProfile}>{rows}</GetMe>;\n    }\n\n    return rows;\n  };\n\n  const renderTableContent = () => {\n    if (isDev) {\n      return <TableRow classes={{\n        root: classes.bodyRow\n      }}>{children}</TableRow>;\n    }\n\n    if (model) {\n      return tableContentModel();\n    }\n\n    return Array.from(Array(amountOfRows).keys()).map(idx => <TableRow key={idx} classes={{\n      root: classes.bodyRow\n    }}>\n\t\t\t\t\t{children}\n\t\t\t\t</TableRow>);\n  };\n\n  useEffect(() => {\n    if (loadOnScroll && !isDev) {\n      const fetchNextSet = () => {\n        fetchingNextSet.current = true;\n\n        if (!initialRender.current) {\n          setSkip(prev => prev + autoLoadTakeAmountNum);\n        }\n\n        initialRender.current = false;\n      };\n\n      const tableContainerElement = tableContainerRef.current;\n\n      if (loadOnScroll) {\n        const parent = tableContainerElement.parentNode;\n\n        if (tableContainerElement.scrollHeight <= parent.clientHeight && initialTimesFetched < 5) {\n          setInitialTimesFetched(prev => prev + 1);\n          fetchNextSet();\n        }\n\n        const scrollEvent = e => {\n          const {\n            scrollTop,\n            clientHeight,\n            scrollHeight\n          } = e.target;\n          const offset = scrollHeight / 5;\n          const hitBottom = scrollTop + clientHeight >= scrollHeight - offset;\n\n          if (hitBottom && !fetchingNextSet.current) {\n            fetchNextSet();\n          }\n        };\n\n        tableContainerElement.addEventListener('scroll', scrollEvent);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (pagination === 'never') {\n      const dataResults = data && data.results;\n      const needsCacheFix = results.length === 0 && dataResults && dataResults.length > 0;\n\n      const setExistingData = () => {\n        setResults(dataResults);\n        fetchingNextSet.current = false;\n      };\n\n      if (needsCacheFix && !autoLoadOnScroll) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip === 0) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip !== 0) {\n        setSkip(0);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (isDev) {\n      if (pagination === 'never') {\n        setShowPagination(false);\n      } else {\n        setShowPagination(true);\n      }\n    }\n  }, [pagination]);\n  useEffect(() => {\n    if (!isDev && data) {\n      switch (pagination) {\n        case 'never':\n          setShowPagination(false);\n          break;\n\n        case 'whenNeeded':\n          if (rowsPerPage >= data.totalCount) {\n            setShowPagination(false);\n          } else {\n            setShowPagination(true);\n          }\n\n          break;\n\n        default:\n        case 'always':\n          setShowPagination(true);\n          break;\n      }\n    }\n  }, [data, rowsPerPage]);\n  useEffect(() => {\n    let amount = 0;\n\n    if (hasToolbar) {\n      amount += toolbarRef.current.clientHeight;\n    }\n\n    if (showPagination) {\n      amount += paginationRef.current.clientHeight;\n    }\n\n    let style;\n\n    if (amount > 0 || !hasToolbar) {\n      style = {\n        height: `calc(100% - ${amount}px)`,\n        borderRadius: `${hasToolbar ? '0rem' : '0.1875rem'}`\n      };\n      setStylesProps({\n        style\n      });\n    } else {\n      setStylesProps(null);\n    }\n  }, [showPagination, hasToolbar]);\n  return <div className={classes.root}>\n\t\t\t\t<Paper classes={{\n      root: classes.paper\n    }} square={square} variant={variant} elevation={elevationLevel}>\n\t\t\t\t\t{hasToolbar && <Toolbar ref={toolbarRef} classes={{\n        root: classes.toolbar\n      }}>\n\t\t\t\t\t\t\t{titleText && <span className={classes.title}>{titleText}</span>}\n\t\t\t\t\t\t\t{searchProperty && !hideSearch && <TextField classes={{\n          root: classes.searchField\n        }} placeholder={`${useText(labelSearchOn)} ${searchPropertyLabel}`} InputProps={{\n          startAdornment: <InputAdornment position='start'>\n\t\t\t\t\t\t\t\t\t\t\t\t<Search />\n\t\t\t\t\t\t\t\t\t\t\t</InputAdornment>\n        }} onChange={handleSearch} />}\n\t\t\t\t\t\t</Toolbar>}\n\t\t\t\t\t<TableContainer ref={tableContainerRef} classes={{\n        root: classes.container\n      }} {...stylesProps}>\n\t\t\t\t\t\t<Table stickyHeader={stickyHeader} size={size} classes={{\n          root: classes.tableRoot\n        }}>\n\t\t\t\t\t\t\t<TableHead>\n\t\t\t\t\t\t\t\t<TableRow classes={{\n              root: classes.headerRow\n            }}>\n\t\t\t\t\t\t\t\t\t{renderTableHead()}\n\t\t\t\t\t\t\t\t</TableRow>\n\t\t\t\t\t\t\t</TableHead>\n\t\t\t\t\t\t\t<TableBody ref={tableRef}>{renderTableContent()}</TableBody>\n\t\t\t\t\t\t\t{isDev && <TableBody ref={repeaterRef} className={classes.autoRepeat} />}\n\t\t\t\t\t\t</Table>\n\t\t\t\t\t</TableContainer>\n\t\t\t\t\t{showPagination && <TablePagination ref={paginationRef} classes={{\n        root: classes.pagination\n      }} rowsPerPageOptions={[5, 10, 25, 50, 100]} labelRowsPerPage={useText(labelRowsPerPage)} labelDisplayedRows={({\n        from,\n        to,\n        count\n      }) => `${from}-${to} ${useText(labelNumberOfPages)} ${count}`} component='div' count={model ? totalCount : takeNum} rowsPerPage={model ? rowsPerPage : takeNum} page={page} onChangePage={handleChangePage} onChangeRowsPerPage={handleChangeRowsPerPage} />}\n\t\t\t\t</Paper>\n\t\t\t</div>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    root: {\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      height: ({\n        options: {\n          height\n        }\n      }) => height\n    },\n    paper: {\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      height: '100%'\n    },\n    container: {\n      height: '100%'\n    },\n    tableRoot: {\n      tableLayout: 'fixed'\n    },\n    toolbar: {\n      paddingLeft: ['1rem', '!important'],\n      paddingRight: ['1rem', '!important']\n    },\n    title: {\n      color: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontColor(titleType),\n      fontFamily: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontFamily(titleType),\n      fontSize: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontSize(titleType),\n      fontWeight: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontWeight(titleType),\n      textTransform: ({\n        options: {\n          titleType\n        }\n      }) => style.getTextTransform(titleType),\n      letterSpacing: ({\n        options: {\n          titleType\n        }\n      }) => style.getLetterSpacing(titleType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Desktop')\n      }\n    },\n    headerRow: {\n      backgroundColor: ({\n        options: {\n          backgroundHeader\n        }\n      }) => [style.getColor(backgroundHeader), '!important'],\n      '& div': {\n        borderBottom: `${isDev ? '0.0625rem solid #cccccc' : 0}`\n      },\n      '& th, & div[role=\"columnheader\"]': {\n        borderBottom: `${isDev ? 0 : '0.0625rem solid #cccccc!important'}`,\n        backgroundColor: ({\n          options: {\n            backgroundHeader\n          }\n        }) => [style.getColor(backgroundHeader), '!important']\n      }\n    },\n    bodyRow: {\n      cursor: ({\n        options: {\n          linkTo\n        }\n      }) => linkTo && linkTo.id !== '' && 'pointer',\n      '&:hover td': {\n        backgroundColor: ({\n          options: {\n            linkTo,\n            backgroundRowHover\n          }\n        }) => linkTo && [style.getColor(backgroundRowHover), '!important']\n      }\n    },\n    searchField: {\n      marginLeft: ['auto', '!important'],\n      pointerEvents: isDev && 'none'\n    },\n    pagination: {\n      borderRadius: '0.1875rem',\n      pointerEvents: isDev && 'none',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important']\n    },\n    autoRepeat: {\n      opacity: 0.5\n    },\n    skeleton: {\n      height: `calc(${style.getFont('Body1').Mobile} * 1.2)`,\n      [`@media ${mediaMinWidth(600)}`]: {\n        height: `calc(${style.getFont('Body1').Portrait} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        height: `calc(${style.getFont('Body1').Landscape} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        height: `calc(${style.getFont('Body1').Desktop} * 1.2)`\n      },\n      backgroundColor: '#eee',\n      borderRadius: 8,\n      overflow: 'hidden',\n      '&::after': {\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        backgroundImage: 'linear-gradient(90deg, #eee 25%, #fff 50%, #eee 75%)',\n        backgroundSize: '200% 100%',\n        backgroundRepeat: 'no-repeat',\n        backgroundPositionX: '150%',\n        borderRadius: `calc(${style.getFont('Body2').Landscape} / 2)`,\n        content: '\"\"',\n        animation: 'loading 1.5s infinite'\n      }\n    },\n    '@keyframes loading': {\n      to: {\n        backgroundPositionX: '-150%'\n      }\n    },\n    [`@media ${mediaMinWidth(600)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Portrait'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Portrait'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Portrait'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Portrait')\n      }\n    },\n    [`@media ${mediaMinWidth(960)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Landscape'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Landscape'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Landscape'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Landscape')\n      }\n    },\n    [`@media ${mediaMinWidth(1280)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Desktop'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Desktop'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Desktop'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Desktop')\n      }\n    }\n  };\n}","functions":["updateFilter","Refetch","SetSearchValue"],"triggers":["onLoad","onError","onSuccess","onNoResults","OnRowClick"]},{"name":"DataTableColumn","type":"DATATABLE_COLUMN","allowedTypes":["CONTENT_COMPONENT","CONTAINER_COMPONENT"],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    env,\n    getProperty,\n    Property,\n    useEndpoint,\n    useText\n  } = B;\n  const {\n    TableCell,\n    TableSortLabel\n  } = window.MaterialUI.Core;\n  const {\n    horizontalAlignment,\n    headerText,\n    property,\n    content,\n    sortable\n  } = options;\n  const {\n    headerOnly,\n    handleSort,\n    orderBy,\n    linkTo,\n    handleRowClick,\n    context\n  } = parent || {};\n  const {\n    type\n  } = property;\n  const propertyArray = [property].flat();\n  const {\n    name: propertyName,\n    label: propertyLabel\n  } = getProperty(property) || {};\n  const {\n    field,\n    order = 'asc'\n  } = orderBy || {};\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const contentPlaceholder = isDev && isEmpty ? 'Select property' : '\\u00A0';\n  let myEndpoint = null;\n\n  if (linkTo) {\n    myEndpoint = useEndpoint(linkTo);\n  }\n\n  const bodyText = useText(content);\n  const propContent = isDev ? `{{ ${propertyName} }}` : <Property id={property} />;\n  let columnText = propertyName ? propContent : contentPlaceholder;\n\n  if (type === 'ME_PROPERTY') {\n    columnText = isDev ? `{{ ${propertyName} }}` : useText([property]);\n  }\n\n  if (bodyText) {\n    columnText = bodyText;\n  }\n\n  const header = useText(headerText);\n  let columnHeaderText = propertyLabel || contentPlaceholder;\n\n  if (header) {\n    columnHeaderText = header;\n  }\n\n  const isSortable = propertyName && sortable;\n\n  const createSortHandler = prop => {\n    const sortOrder = order === 'asc' ? 'desc' : 'asc';\n    handleSort(prop, sortOrder);\n  };\n\n  const isFilterSelected = fields => {\n    if (!fields || fields.length !== propertyArray.length) return false;\n\n    for (let index = 0; index < fields.length; index += 1) {\n      if (fields[index] !== propertyArray[index]) return false;\n    }\n\n    return true;\n  };\n\n  const Content = children.length > 0 ? children : <span className={classes.content}>{columnText}</span>;\n  const Header = isSortable ? <TableSortLabel classes={{\n    root: classes.columnSort\n  }} active={isFilterSelected(field)} direction={isFilterSelected(field) && order ? order : 'asc'} onClick={() => createSortHandler(propertyArray)}>\n\t\t\t\t<span className={classes.columnHeader}>{columnHeaderText}</span>\n\t\t\t</TableSortLabel> : <span className={classes.columnHeader}>{columnHeaderText}</span>;\n  const [visible, setVisible] = useState(false);\n  useEffect(() => {\n    setVisible(options.visible);\n  }, []);\n  B.defineFunction('Hide', () => setVisible(false));\n  B.defineFunction('Show', () => setVisible(true));\n  B.defineFunction('Show/Hide', () => setVisible(s => !s));\n\n  if (isDev) {\n    return <div className={[classes.tableColumn, !headerOnly ? classes.tableColumnBody : '', !headerOnly ? 'MuiTableCell-root' : ''].join(' ')}>\n\t\t\t\t\t{headerOnly ? <TableCell align={horizontalAlignment} component='div'>\n\t\t\t\t\t\t\t{Header}\n\t\t\t\t\t\t</TableCell> : Content}\n\t\t\t\t</div>;\n  }\n\n  return visible ? <TableCell classes={{\n    root: classes.root\n  }} align={horizontalAlignment} onClick={() => handleRowClick && handleRowClick(myEndpoint, context)}>\n\t\t\t\t{headerOnly ? Header : Content}\n\t\t\t</TableCell> : <></>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n  return {\n    tableColumn: {\n      display: 'table-cell',\n      verticalAlign: 'middle',\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      '& > div': {\n        display: 'block'\n      }\n    },\n    tableColumnBody: {\n      textAlign: ({\n        options: {\n          horizontalAlignment\n        }\n      }) => [horizontalAlignment, '!important'],\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    root: {\n      display: isDev && ['block', '!important'],\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    columnHeader: {\n      color: ({\n        options: {\n          type\n        }\n      }) => style.getFontColor(type),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Desktop')\n      }\n    },\n    content: {\n      color: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontColor(bodyType),\n      fontFamily: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontFamily(bodyType),\n      fontSize: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontSize(bodyType),\n      fontWeight: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontWeight(bodyType),\n      textTransform: ({\n        options: {\n          bodyType\n        }\n      }) => style.getTextTransform(bodyType),\n      letterSpacing: ({\n        options: {\n          bodyType\n        }\n      }) => style.getLetterSpacing(bodyType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Desktop')\n      }\n    },\n    columnSort: {\n      pointerEvents: isDev && 'none',\n      '& .MuiSvgIcon-root': {\n        opacity: isDev && 0.5\n      }\n    }\n  };\n}","functions":["Hide","Show","Show/Hide"],"triggers":[]},{"name":"DateTimePicker","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    useAsFilter,\n    filterBy,\n    filterType,\n    disabled,\n    error,\n    placeholder,\n    variant,\n    inputvariant,\n    type,\n    dateFormat,\n    timeFormat,\n    dateTimeFormat,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    disableToolbar,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    use24HourClockDateTime,\n    use24HourClockTime,\n    nameAttribute,\n    locale\n  } = options;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText,\n    useFilter,\n    getProperty\n  } = B;\n  const {\n    MuiPickersUtilsProvider,\n    KeyboardTimePicker,\n    KeyboardDatePicker,\n    KeyboardDateTimePicker\n  } = window.MaterialUI.Pickers;\n  const {\n    DateFnsUtils\n  } = window.MaterialUI;\n  const {\n    nlLocale,\n    enLocale\n  } = window.MaterialUI.DateLocales;\n  const {\n    AccessTime,\n    Event\n  } = window.MaterialUI.Icons;\n  const DateFns = new DateFnsUtils();\n  const isDev = env === 'dev';\n  const [selectedDate, setSelectedDate] = useState(null);\n  const helper = useText(helperText);\n  const placeholderText = useText(placeholder);\n  const rawFilterBy = useFilter(filterBy);\n  const filterProp = Object.keys(filterBy);\n  const filterPropType = isDev ? null : getProperty(filterProp[0]).kind;\n  const localeMap = {\n    nl: nlLocale,\n    en: enLocale\n  };\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const strDefaultValue = useText(defaultValue);\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n\n  const isValidDate = date => date instanceof Date && !isNaN(date);\n\n  const toJSONLocal = date => {\n    var local = new Date(date);\n    local.setMinutes(date.getMinutes() - date.getTimezoneOffset());\n    return local.toJSON().slice(0, 10);\n  };\n\n  const changeHandler = date => {\n    setSelectedDate(date);\n\n    if (useAsFilter) {\n      if (date !== null) {\n        const value = getDeepestObject(rawFilterBy);\n        const parsedDate = filterPropType === 'date' ? toJSONLocal(date) : date.toISOString();\n        setDeepestKey(rawFilterBy, value, parsedDate);\n        B.triggerEvent('sendFilter', {\n          filter: rawFilterBy,\n          label: labelText\n        });\n      } else {\n        B.triggerEvent('sendFilter', {\n          filter: undefined,\n          label: labelText\n        });\n      }\n    }\n  };\n\n  const getDeepestObject = obj => {\n    if (typeof obj[Object.keys(obj)] === 'object') {\n      return getDeepestObject(obj[Object.keys(obj)]);\n    }\n\n    return obj;\n  };\n\n  const setDeepestKey = (obj, value, newCurrentValue) => {\n    if (Object.values(obj).includes(value)) {\n      const key = Object.keys(obj);\n      return obj[key] = {\n        [filterType]: newCurrentValue\n      };\n    }\n\n    return setDeepestKey(obj[Object.keys(obj)], value, newCurrentValue);\n  };\n\n  const setDefaultDate = (defaultFormat, givenFormat) => {\n    if (!selectedDate && strDefaultValue) {\n      const propDefaultParse = defaultFormat ? DateFns.parse(strDefaultValue, defaultFormat) : new Date(strDefaultValue);\n      const formatDefaultParse = DateFns.parse(strDefaultValue, givenFormat);\n\n      if (isValidDate(propDefaultParse)) {\n        setSelectedDate(propDefaultParse);\n      } else if (isValidDate(formatDefaultParse)) {\n        setSelectedDate(formatDefaultParse);\n      } else {\n        setSelectedDate(DateFns.parse('00:00:00', 'HH:mm:ss'));\n      }\n    }\n  };\n\n  B.defineFunction('Clear', () => setSelectedDate(null));\n  let DateTimeComponent;\n  let format;\n  let resultString;\n  let use24HourClock = true;\n\n  switch (type) {\n    case 'date':\n      {\n        DateTimeComponent = KeyboardDatePicker;\n        format = dateFormat || 'dd/MM/yyyy';\n        setDefaultDate('yyyy-MM-dd', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'yyyy-MM-dd') : null;\n        break;\n      }\n\n    case 'datetime':\n      {\n        DateTimeComponent = KeyboardDateTimePicker;\n        format = dateTimeFormat || 'dd/MM/yyyy HH:mm:ss';\n        use24HourClock = use24HourClockDateTime;\n        setDefaultDate(null, format);\n        resultString = isValidDate(selectedDate) ? new Date(selectedDate).toISOString() : new Date().toISOString();\n        break;\n      }\n\n    case 'time':\n      {\n        DateTimeComponent = KeyboardTimePicker;\n        format = timeFormat || 'HH:mm:ss';\n        use24HourClock = use24HourClockTime;\n        setDefaultDate('HH:mm:ss', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'HH:mm:ss') : null;\n        break;\n      }\n\n    default:\n  }\n\n  const DateTimeCmp = <DateTimeComponent name={nameAttributeValue || customModelAttributeName} value={selectedDate} size={size} classes={{\n    root: classes.formControl\n  }} variant={variant} placeholder={placeholderText} fullWidth={fullWidth} onChange={changeHandler} inputVariant={inputvariant} InputProps={{\n    inputProps: {\n      name: nameAttributeValue || customModelAttributeName,\n      tabIndex: isDev && -1\n    }\n  }} KeyboardButtonProps={{\n    tabIndex: isDev && -1\n  }} required={required} disabled={disabled} label={!hideLabel && labelText} error={error} margin={margin} helperText={helper} disableToolbar={disableToolbar} format={format} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} DialogProps={{\n    className: classes.dialog\n  }} ampm={!use24HourClock} keyboardIcon={type === 'time' ? <AccessTime /> : <Event />} />;\n  return isDev ? <div className={classes.root}>\n\t\t\t\t<MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t\t</MuiPickersUtilsProvider>\n\t\t\t</div> : <MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t<input type='hidden' name={nameAttributeValue || customModelAttributeName} value={resultString} />\n\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t</MuiPickersUtilsProvider>;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    dialog: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      },\n      '& .MuiButton-textPrimary': {\n        color: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    popover: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            inputvariant\n          }\n        }) => inputvariant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    },\n    static: {\n      '& .MuiPickersStaticWrapper-staticWrapperRoot': {\n        '& .MuiToolbar-root, & .MuiPickersDay-daySelected': {\n          backgroundColor: ({\n            options: {\n              backgroundColorPopup\n            }\n          }) => [style.getColor(backgroundColorPopup), '!important']\n        }\n      }\n    }\n  };\n}","functions":["Clear"],"triggers":["sendFilter","sendFilter"]},{"name":"AutoComplete","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    useAsFilter,\n    filterBy,\n    filterType,\n    disabled,\n    error,\n    placeholder,\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    model,\n    multiple,\n    freeSolo,\n    searchProperty,\n    valueProperty,\n    closeOnSelect,\n    renderCheckboxes,\n    showError,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    property,\n    nameAttribute,\n    order,\n    orderBy\n  } = options;\n  const {\n    Autocomplete\n  } = window.MaterialUI.Lab;\n  const {\n    TextField,\n    CircularProgress,\n    Chip,\n    Checkbox\n  } = window.MaterialUI.Core;\n  const {\n    ExpandMore,\n    Close,\n    CheckBox,\n    CheckBoxOutlineBlank\n  } = window.MaterialUI.Icons;\n  const {\n    useText,\n    getProperty,\n    getCustomModelAttribute,\n    useAllQuery,\n    env\n  } = B;\n  const isDev = env === 'dev';\n  const displayError = showError === 'built-in';\n  const placeholderText = useText(placeholder);\n  const helper = useText(helperText);\n  const nameAttributeValue = useText(nameAttribute);\n  const rawFilterBy = B.useFilter(filterBy);\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const {\n    kind,\n    values: listValues\n  } = getProperty(property) || {};\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const [currentLabel, setCurrentLabel] = useState('');\n  const labelText = useText(label);\n  const textFieldProps = {\n    disabled,\n    variant,\n    label: !hideLabel && labelText,\n    fullWidth,\n    size,\n    type,\n    required,\n    error,\n    placeholder: placeholderText,\n    margin,\n    helperText: helper,\n    classes: {\n      root: classes.formControl\n    }\n  };\n  const searchProp = getProperty(searchProperty) || {};\n  const valueProp = getProperty(valueProperty) || {};\n  const [searchParam, setSearchParam] = useState('');\n  const [debouncedSearchParam, setDebouncedSearchParam] = useState('');\n  const {\n    filter\n  } = options;\n  const hasSearch = searchProp && searchProp.id;\n  const hasValue = valueProp && valueProp.id;\n\n  if (hasSearch && debouncedSearchParam !== '') {\n    filter[searchProp.id] = {\n      regex: debouncedSearchParam\n    };\n  } else if (hasSearch && debouncedSearchParam === '') {\n    delete filter[searchProp.id];\n  }\n\n  const hasNoProp = !hasSearch || !hasValue;\n  const reason = hasNoProp ? 'No property selected' : 'No data';\n  let inputProps = {\n    inputProps: {\n      tabIndex: isDev && -1\n    },\n    endAdornment: <>\n\t\t\t\t\t{currentValue && <Close />}\n\t\t\t\t\t{!freeSolo && <ExpandMore />}\n\t\t\t\t</>\n  };\n\n  if (multiple && currentValue) {\n    inputProps = { ...inputProps,\n      startAdornment: <Chip label={currentValue} onDelete={() => {}} />\n    };\n  }\n\n  const valueArray = currentValue ? currentValue.toString().split(',') : [];\n  const rawFilter = {\n    rawFilter: {\n      [valueProp.name]: {\n        in: valueArray\n      }\n    }\n  };\n  const [useFilter, setUseFilter] = useState(currentValue ? rawFilter : filter);\n\n  const resetFilter = () => {\n    setUseFilter({\n      filter\n    });\n  };\n\n  const orderByArray = [orderBy].flat();\n  const sort = !isDev && orderBy ? orderByArray.reduceRight((acc, orderByProperty, index) => {\n    const prop = getProperty(orderByProperty);\n    return index === orderByArray.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const {\n    loading,\n    error: err,\n    data,\n    refetch\n  } = model && useAllQuery(model, { ...useFilter,\n    skip: 0,\n    take: 50,\n    variables: { ...(orderBy ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    }\n  });\n  useEffect(() => {\n    if (!isDev && data) {\n      resetFilter();\n    }\n  }, [data]);\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n    }\n  }, [isDev, defaultValue]);\n  B.defineFunction('Clear', () => setCurrentValue(null));\n  B.defineFunction('Refetch', () => refetch());\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedSearchParam(searchParam);\n    }, 1000);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchParam]);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n\n  if (err && !displayError) {\n    B.triggerEvent('onError', err);\n  }\n\n  const {\n    results\n  } = data || {};\n\n  if (results) {\n    if (results.length > 0) {\n      B.triggerEvent('onSuccess', results);\n    } else {\n      B.triggerEvent('onNoResults');\n    }\n  }\n\n  const onChange = (_, newValue) => {\n    if (!valueProp || !newValue) {\n      setCurrentValue(newValue);\n      setCurrentLabel(newValue);\n      B.triggerEvent('OnChange', newValue);\n      B.triggerEvent('sendFilter', {\n        filter: undefined,\n        label: labelText\n      });\n      return;\n    }\n\n    let newCurrentValue = newValue[valueProp.name] || newValue;\n\n    if (typeof newValue === 'string') {\n      if (currentLabel === newValue) {\n        newCurrentValue = currentValue;\n      }\n    } else if (searchProp) {\n      const newLabelValue = newValue[searchProp.name];\n      setCurrentLabel(newLabelValue);\n    }\n\n    if (multiple) {\n      newCurrentValue = newValue.map(rec => rec[valueProp.name] || rec);\n    }\n\n    setCurrentValue(newCurrentValue);\n    B.triggerEvent('OnChange', newCurrentValue);\n\n    if (useAsFilter) {\n      if (multiple && newCurrentValue.length > 0 || !multiple) {\n        const value = getDeepestObject(rawFilterBy);\n        setDeepestKey(rawFilterBy, value, newCurrentValue);\n        B.triggerEvent('sendFilter', {\n          filter: rawFilterBy,\n          label: labelText\n        });\n      } else {\n        B.triggerEvent('sendFilter', {\n          filter: undefined,\n          label: labelText\n        });\n      }\n    }\n  };\n\n  const getDeepestObject = obj => {\n    if (typeof obj[Object.keys(obj)] === 'object') {\n      return getDeepestObject(obj[Object.keys(obj)]);\n    }\n\n    return obj;\n  };\n\n  const setDeepestKey = (obj, value, newCurrentValue) => {\n    if (Object.values(obj).includes(value)) {\n      const key = Object.keys(obj);\n      return obj[key] = {\n        [filterType]: newCurrentValue\n      };\n    }\n\n    return setDeepestKey(obj[Object.keys(obj)], value, newCurrentValue);\n  };\n\n  const getDefaultValue = React.useCallback(() => {\n    if (!currentValue || !results) {\n      return multiple ? [] : null;\n    }\n\n    let currentRecordsKeys = currentValue;\n\n    if (!Array.isArray(currentValue)) {\n      currentRecordsKeys = multiple ? currentValue.toString().split(',') : [currentValue];\n    }\n\n    const currentRecords = results.reduce((acc, cv) => {\n      const searchStr = cv[valueProp.name].toString();\n      const search = cv[valueProp.name];\n\n      if (currentRecordsKeys.indexOf(searchStr) > -1 || currentRecordsKeys.indexOf(search) > -1) {\n        acc.push(cv);\n      }\n\n      return acc;\n    }, []);\n    const singleRecord = currentRecords[0] ? { ...currentRecords[0]\n    } : null;\n    return multiple ? currentRecords : singleRecord;\n  }, [results]);\n  const defaultRecord = getDefaultValue();\n  useEffect(() => {\n    if (!multiple && defaultRecord && searchProp) {\n      setCurrentLabel(defaultRecord[searchProp.name]);\n    }\n  }, [defaultRecord]);\n\n  const renderLabel = option => {\n    const optionLabel = option[searchProp.name];\n    return optionLabel !== undefined && optionLabel === '' ? '-- empty --' : optionLabel && optionLabel.toString() || option;\n  };\n\n  const renderOption = (option, {\n    selected\n  }) => <>\n\t\t\t\t<Checkbox classes={{\n      root: classes.checkbox\n    }} icon={<CheckBoxOutlineBlank fontSize='small' />} checkedIcon={<CheckBox fontSize='small' />} style={{\n      marginRight: 8\n    }} checked={selected} />\n\t\t\t\t{renderLabel(option)}\n\t\t\t</>;\n\n  if (isDev) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (kind === 'list' || kind === 'LIST') {\n    const onPropertyListChange = (_, newValue) => {\n      setCurrentValue(newValue);\n      B.triggerEvent('OnChange');\n    };\n\n    const selectValues = listValues.map(({\n      value\n    }) => value).filter(e => e.startsWith(searchParam)) || [];\n    return <Autocomplete id='combo-box-demo' options={selectValues} value={currentValue} PopoverProps={{\n      classes: {\n        root: classes.popover\n      }\n    }} onInputChange={(_, inputValue) => {\n      setSearchParam(inputValue);\n    }} onChange={onPropertyListChange} getOptionLabel={option => option} renderInput={params => <TextField {...params} {...textFieldProps} name={nameAttributeValue || customModelAttributeName} key={currentValue ? 'hasValue' : 'isEmpty'} required={required && !currentValue} InputProps={{ ...params.InputProps,\n      endAdornment: params.InputProps.endAdornment\n    }} />} />;\n  }\n\n  if (!model) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (err && displayError) return <span>{err.message}</span>;\n\n  if (!data || hasNoProp) {\n    return <TextField {...textFieldProps} defaultValue={reason} disabled InputProps={{\n      endAdornment: <CircularProgress color='inherit' size={20} />\n    }} />;\n  }\n\n  return <Autocomplete multiple={multiple} freeSolo={freeSolo} autoSelect={freeSolo} options={results} defaultValue={defaultRecord} getOptionLabel={renderLabel} getOptionSelected={(option, value) => value.id === option.id} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} onInputChange={(_, inputValue) => {\n    if (!freeSolo) {\n      return;\n    }\n\n    setSearchParam(inputValue);\n  }} onChange={onChange} disableCloseOnSelect={!closeOnSelect} renderOption={renderCheckboxes && renderOption} renderInput={params => <>\n\t\t\t\t\t\t<input type='hidden' key={currentValue ? 'hasValue' : 'isEmpty'} name={nameAttributeValue || customModelAttributeName} value={currentValue} />\n\t\t\t\t\t\t<TextField {...params} {...textFieldProps} required={required && (!currentValue || currentValue.length === 0)} loading={loading} InputProps={{ ...params.InputProps,\n      endAdornment: <>\n\t\t\t\t\t\t\t\t\t\t{loading ? <CircularProgress color='inherit' size={20} /> : null}\n\t\t\t\t\t\t\t\t\t\t{params.InputProps.endAdornment}\n\t\t\t\t\t\t\t\t\t</>\n    }} />\n\t\t\t\t\t</>} />;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  const {\n    color: colorFunc\n  } = B;\n\n  const getOpacColor = (col, val) => colorFunc.alpha(col, val);\n\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    checkbox: {\n      color: ({\n        options: {\n          checkboxColor\n        }\n      }) => [style.getColor(checkboxColor), '!important'],\n      '&.MuiCheckbox-root.Mui-checked:hover, &.MuiIconButton-root:hover': {\n        backgroundColor: ({\n          options: {\n            checkboxColor\n          }\n        }) => [getOpacColor(style.getColor(checkboxColor), 0.04), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            variant\n          }\n        }) => variant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        },\n        '& .MuiChip-root': {\n          color: ({\n            options: {\n              textColorChip\n            }\n          }) => [style.getColor(textColorChip), '!important'],\n          backgroundColor: ({\n            options: {\n              backgroundColorChip\n            }\n          }) => [style.getColor(backgroundColorChip), '!important']\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Refetch"],"triggers":["onLoad","onError","onSuccess","onNoResults","OnChange","sendFilter","OnChange","sendFilter","sendFilter","OnChange"]},{"name":"Menu","type":"CONTENT_COMPONENT","allowedTypes":["CONTENT_COMPONENT","CONTAINER_COMPONENT"],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    Button,\n    Menu,\n    Avatar\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    visible,\n    variant,\n    dropdownVariant,\n    anchorPositionVertical,\n    anchorPositionHorizontal,\n    popoverPositionHorizontal,\n    popoverPositionVertical,\n    fullWidth,\n    size,\n    icon,\n    iconPosition,\n    textPosition,\n    type,\n    imgUrl,\n    letter,\n    text\n  } = options;\n  const {\n    env,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const [isVisible, setIsVisible] = useState(visible);\n  const isIcon = variant === 'icon';\n  const isAvatar = variant === 'avatar';\n\n  if (isAvatar) {\n    const isLetter = type === 'letter';\n    const isImage = type === 'img';\n    const imgSrc = useText(imgUrl);\n  }\n\n  const content = useText(text);\n  const anchorRef = useRef(null);\n  const [open, setOpen] = useState(false);\n  useEffect(() => {\n    setIsVisible(visible);\n  }, [visible]);\n\n  const handleClose = event => {\n    if (anchorRef.current && anchorRef.current.contains(event.target)) {\n      return;\n    }\n\n    setOpen(false);\n  };\n\n  const handleClick = () => {\n    setOpen(!open);\n  };\n\n  const generalProps = {\n    size,\n    tabindex: isDev && -1\n  };\n  const compProps = { ...generalProps,\n    fullWidth,\n    variant,\n    classes: {\n      root: classes.root,\n      contained: classes.contained,\n      outlined: classes.outlined\n    },\n    type: 'button'\n  };\n  const MenuComponent = <>\n        <Button {...compProps} ref={anchorRef} startIcon={!isIcon && icon !== 'None' && iconPosition === 'start' && React.createElement(Icons[icon])} endIcon={!isIcon && icon !== 'None' && iconPosition === 'end' && React.createElement(Icons[icon])} onClick={handleClick}>\n          {isIcon && React.createElement(Icons[icon === 'None' ? 'Error' : icon], {\n        fontSize: size\n      })}\n          {isAvatar && <>\n              {content && textPosition === 'start' && <span className={classes.contentStart}>{content}</span>}\n              <Avatar variant={variant} src={isImage && imgSrc} className={classes.avatar}>\n                {isLetter && useText(letter)}\n              </Avatar>\n              {content && textPosition === 'end' && <span className={classes.contentEnd}>{content}</span>}\n            </>}\n          {!isIcon && !isAvatar && content}\n        </Button>\n        {isDev && isVisible ? <div className={[isEmpty ? classes.empty : '', classes.pristine].join(' ')}>\n            {children}\n          </div> : <Menu className={dropdownVariant === 'outlined' ? classes.menu : ''} anchorEl={anchorRef.current} keepMounted open={open} onClose={handleClose} elevation={dropdownVariant === 'elevation' ? 8 : 0} anchorOrigin={{\n      vertical: anchorPositionVertical,\n      horizontal: anchorPositionHorizontal\n    }} transformOrigin={{\n      vertical: popoverPositionVertical,\n      horizontal: popoverPositionHorizontal\n    }}>\n            {children}\n          </Menu>}\n      </>;\n\n  if (isDev) {\n    return <div className={classes.wrapper}>{MenuComponent}</div>;\n  }\n\n  return MenuComponent;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    empty: {\n      minHeight: '4rem'\n    },\n    pristine: {\n      display: 'flex',\n      flexDirection: 'column',\n      position: 'fixed',\n      width: 'auto',\n      borderWidth: '0.0625rem',\n      borderColor: '#AFB5C8',\n      borderStyle: 'dashed',\n      backgroundColor: '#F0F1F5'\n    },\n    wrapper: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      width: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth && '100%'\n    },\n    root: {\n      color: ({\n        options: {\n          background,\n          textColor,\n          variant\n        }\n      }) => [textColor ? style.getColor(variant === 'icon' ? background : textColor) : 'rgba(0, 0, 0, 0.26)', '!important'],\n      width: ({\n        options: {\n          fullWidth,\n          outerSpacing\n        }\n      }) => {\n        if (!fullWidth) return 'auto';\n        const marginRight = getSpacing(outerSpacing[1]);\n        const marginLeft = getSpacing(outerSpacing[3]);\n        return `calc(100% - ${marginRight} - ${marginLeft})`;\n      },\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      '&.MuiButton-root, &.MuiIconButton-root': {\n        textTransform: ({\n          options: {\n            uppercase\n          }\n        }) => uppercase ? 'uppercase' : 'none',\n        [`@media ${B.mediaMinWidth(600)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Portrait');\n            const marginLeft = getSpacing(outerSpacing[3], 'Portrait');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Portrait'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Portrait'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Portrait'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Portrait')\n        },\n        [`@media ${B.mediaMinWidth(960)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Landscape');\n            const marginLeft = getSpacing(outerSpacing[3], 'Landscape');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Landscape'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Landscape'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Landscape'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Landscape')\n        },\n        [`@media ${B.mediaMinWidth(1280)}`]: {\n          width: ({\n            options: {\n              fullWidth,\n              outerSpacing\n            }\n          }) => {\n            if (!fullWidth) return 'auto';\n            const marginRight = getSpacing(outerSpacing[1], 'Desktop');\n            const marginLeft = getSpacing(outerSpacing[3], 'Desktop');\n            return `calc(100% - ${marginRight} - ${marginLeft})`;\n          },\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Desktop'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Desktop'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Desktop'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Desktop')\n        }\n      }\n    },\n    contained: {\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [background ? style.getColor(background) : 'rgba(0, 0, 0, 0.12)', '!important']\n    },\n    menu: {\n      '& .MuiMenu-paper': {\n        border: '1px solid #d3d4d5'\n      }\n    },\n    avatar: {\n      color: ({\n        options: {\n          letterColor\n        }\n      }) => [style.getColor(letterColor), '!important'],\n      backgroundColor: ({\n        options: {\n          avatarColor\n        }\n      }) => [style.getColor(avatarColor), '!important'],\n      fontWeight: ({\n        options: {\n          fontWeight\n        }\n      }) => fontWeight,\n      '&.MuiAvatar-root': {\n        fontSize: ({\n          options: {\n            fontSize\n          }\n        }) => fontSize\n      }\n    },\n    contentStart: {\n      marginRight: '8px'\n    },\n    contentEnd: {\n      marginLeft: '8px'\n    }\n  };\n}","functions":[],"triggers":[]},{"name":"MenuItem","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    MenuItem\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    disabled,\n    icon,\n    iconPosition,\n    linkType,\n    linkTo,\n    linkToExternal,\n    type,\n    actionId,\n    text,\n    actionProperties\n  } = options;\n  const {\n    env,\n    useText,\n    useAction\n  } = B;\n  const isDev = env === 'dev';\n  const isAction = linkType === 'action';\n  const hasLink = linkTo && linkTo.id !== '';\n  const hasExternalLink = linkToExternal && linkToExternal.id !== '';\n  const linkToExternalVariable = linkToExternal && useText(linkToExternal) || '';\n  const content = useText(text);\n  const [isLoading, setIsLoading] = useState(false);\n  const propertyMappings = new Map(actionProperties);\n  const input = Array.from(propertyMappings.keys()).reduce((acc, key) => {\n    const propertyId = propertyMappings.get(key);\n    const value = isDev ? '' : B.useProperty(propertyId);\n    acc[key] = value;\n    return acc;\n  }, {});\n  const [actionCallback, {\n    loading\n  }] = isAction && useAction(actionId, {\n    variables: {\n      input\n    },\n\n    onCompleted(data) {\n      B.triggerEvent('onActionSuccess', data.actionb5);\n    },\n\n    onError(error) {\n      B.triggerEvent('onActionError', error);\n    }\n\n  }) || [() => {}, {\n    loading: false\n  }];\n  useEffect(() => {\n    if (loading) {\n      B.triggerEvent('onActionLoad', loading);\n    }\n  }, [loading]);\n  const generalProps = {\n    disabled: disabled || isLoading || loading,\n    href: linkType === 'external' && hasExternalLink ? linkToExternalVariable : undefined,\n    component: linkType === 'internal' && hasLink ? B.Link : linkType === 'external' ? 'a' : undefined,\n    endpoint: linkType === 'internal' && hasLink ? linkTo : undefined\n  };\n  const compProps = { ...generalProps,\n    classes: {\n      root: classes.root\n    },\n    type: isDev ? 'button' : type\n  };\n  const MenuItemComponent = <MenuItem {...compProps} onClick={event => {\n    event.stopPropagation();\n    actionCallback();\n  }}>\n        {icon !== 'None' && iconPosition === 'start' && <span className={classes.iconStart}>\n            {React.createElement(Icons[icon])}\n          </span>}\n        {content}\n        {icon !== 'None' && iconPosition === 'end' && <span className={classes.iconEnd}>\n            {React.createElement(Icons[icon])}\n          </span>}\n      </MenuItem>;\n\n  if (isDev) {\n    return <div className={classes.wrapper}>{MenuItemComponent}</div>;\n  }\n\n  return MenuItemComponent;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    wrapper: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      width: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth && '100%',\n      minHeight: '1rem',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    root: {\n      '&.MuiMenuItem-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [textColor ? style.getColor(textColor) : 'rgba(0, 0, 0, 0.26)', '!important'],\n        width: '100%',\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0]),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1]),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2]),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3]),\n        [`@media ${B.mediaMinWidth(600)}`]: {\n          width: '100%',\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Portrait'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Portrait'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Portrait'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Portrait')\n        },\n        [`@media ${B.mediaMinWidth(960)}`]: {\n          width: '100%',\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Landscape'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Landscape'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Landscape'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Landscape')\n        },\n        [`@media ${B.mediaMinWidth(1280)}`]: {\n          width: '100%',\n          marginTop: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[0], 'Desktop'),\n          marginRight: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[1], 'Desktop'),\n          marginBottom: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[2], 'Desktop'),\n          marginLeft: ({\n            options: {\n              outerSpacing\n            }\n          }) => getSpacing(outerSpacing[3], 'Desktop')\n        }\n      }\n    },\n    iconStart: {\n      marginRight: '8px',\n      verticalAlign: 'middle',\n      display: 'flex'\n    },\n    iconEnd: {\n      marginLeft: '8px',\n      verticalAlign: 'middle',\n      display: 'flex'\n    },\n    empty: {\n      '&::before': {\n        content: '\"\\\\xA0\"'\n      }\n    }\n  };\n}","functions":[],"triggers":["onActionSuccess","onActionError","onActionLoad"]},{"name":"customStyleSheet","icon":"HtmlIcon","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const isDev = B.env === 'dev';\n  const head = document.getElementsByTagName('head')[0];\n  const link = document.createElement('link');\n  link.type = 'text/css';\n  link.rel = 'stylesheet';\n  link.href = options.styleSheetUrl;\n  head.appendChild(link);\n  return <div className={isDev && classes.root}>{isDev && 'customStyleSheet'}</div>;\n})()","styles":"() => () => ({\n  root: {\n    borderWidth: '0.0625rem',\n    borderColor: '#AFB5C8',\n    borderStyle: 'dashed',\n    backgroundColor: '#F0F1F5',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    minHeight: '2rem',\n    width: '100%',\n    fontSize: '0.75rem',\n    color: '#262A3A',\n    textTransform: 'uppercase',\n    boxSizing: 'border-box',\n    textAlign: 'center'\n  }\n})","functions":[],"triggers":[]},{"name":"TextWithInteraction","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    content,\n    useInnerHtml,\n    textToTarget\n  } = options;\n  const {\n    env\n  } = B;\n  const isDev = env === 'dev';\n  const Tag = useInnerHtml ? 'div' : {\n    Title1: 'h1',\n    Title2: 'h2',\n    Title3: 'h3',\n    Title4: 'h4',\n    Title5: 'h5',\n    Title6: 'h6',\n    Body1: 'p',\n    Body2: 'p'\n  }[options.type || 'Body1'];\n  const parsedContent = B.useText(content);\n\n  const targetClicked = () => {\n    B.triggerEvent('TargetClicked');\n  };\n\n  useEffect(() => {\n    const span = document.getElementById('target');\n\n    if (span != null) {\n      span.addEventListener('click', () => {\n        targetClicked();\n      });\n    }\n  }, []);\n  const clickElement = `<span id=\"target\">${textToTarget}</span>`;\n  const targetText = new RegExp(textToTarget, 'g');\n  const newContent = parsedContent.replace(targetText, clickElement);\n  return !isDev ? <Tag className={classes.content} dangerouslySetInnerHTML={{\n    __html: newContent\n  }} /> : <Tag className={classes.content}>{parsedContent}</Tag>;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    content: {\n      '& #target': {\n        cursor: 'pointer'\n      },\n      display: 'block',\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      textAlign: ({\n        options: {\n          textAlignment\n        }\n      }) => textAlignment,\n      padding: 0,\n      whiteSpace: 'pre-wrap',\n      color: ({\n        options: {\n          textColor\n        }\n      }) => style.getColor(textColor),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      fontWeight: ({\n        options: {\n          fontWeight\n        }\n      }) => fontWeight,\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      [`@media ${B.mediaMinWidth(600)}`]: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Portrait'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Portrait'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Portrait'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Portrait'),\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Portrait')\n      },\n      [`@media ${B.mediaMinWidth(960)}`]: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Landscape'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Landscape'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Landscape'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Landscape'),\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Landscape')\n      },\n      [`@media ${B.mediaMinWidth(1280)}`]: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Desktop'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Desktop'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Desktop'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Desktop'),\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Desktop')\n      }\n    },\n    placeholder: {\n      color: '#dadde4'\n    }\n  };\n}","functions":[],"triggers":["TargetClicked"]},{"name":"Tooltip","type":"CONTENT_COMPONENT","allowedTypes":["LIST_ITEM","LIST_SUBHEADER","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Tooltip\n  } = window.MaterialUI.Core;\n  const {\n    content,\n    placement\n  } = options;\n  const {\n    env,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const contentValue = useText(content);\n  const tooltipRef = useRef();\n  const [hoverStatus, setHover] = useState(false);\n\n  const compareSize = () => {\n    if (showTooltipWhenNeeded) {\n      const compare = tooltipRef.current.firstChild.scrollWidth > tooltipRef.current.firstChild.clientWidth;\n      setHover(compare);\n    }\n  }; // compare once and add resize listener on \"componentDidMount\"\n\n\n  useEffect(() => {\n    compareSize();\n    B.defineFunction('recalculateTooltip', () => compareSize());\n    window.addEventListener('resize', compareSize);\n  }, []); // remove resize listener again on \"componentWillUnmount\"\n\n  useEffect(() => () => {\n    window.removeEventListener('resize', compareSize);\n  }, []);\n  const TooltipComponent = <Tooltip title={contentValue !== '' && isDev ? 'Tooltip' : contentValue} placement={placement} disableHoverListener={false} enterDelay={500} ref={tooltipRef} leaveDelay={200} arrow>\n\t\t\t\t<span className={classes.wrapper}>\n\t\t\t\t\t{isDev && isEmpty ? 'Tooltip' : children}\n\t\t\t\t</span>\n\t\t\t</Tooltip>;\n  return isDev ? <div>{TooltipComponent}</div> : TooltipComponent;\n})()","styles":"() => () => ({\n  wrapper: {\n    display: 'inline-block'\n  }\n})","functions":["recalculateTooltip"],"triggers":[]}]
