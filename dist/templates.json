[{"name":"AutoComplete","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    disabled,\n    error,\n    placeholder,\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    model,\n    multiple,\n    freeSolo,\n    searchProperty,\n    valueProperty,\n    closeOnSelect,\n    renderCheckboxes,\n    showError,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    property,\n    nameAttribute,\n    order,\n    orderBy\n  } = options;\n  const {\n    Autocomplete\n  } = window.MaterialUI.Lab;\n  const {\n    TextField,\n    CircularProgress,\n    Chip,\n    Checkbox\n  } = window.MaterialUI.Core;\n  const {\n    ExpandMore,\n    Close,\n    CheckBox,\n    CheckBoxOutlineBlank\n  } = window.MaterialUI.Icons;\n  const {\n    env,\n    getCustomModelAttribute,\n    getProperty,\n    useAllQuery,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const displayError = showError === 'built-in';\n  const placeholderText = useText(placeholder);\n  const helper = useText(helperText);\n  const nameAttributeValue = useText(nameAttribute);\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const {\n    kind,\n    values: listValues\n  } = getProperty(property) || {};\n  const [currentValue, setCurrentValue] = useState(parseInt(useText(defaultValue)));\n  const [currentLabel, setCurrentLabel] = useState('');\n  const mounted = useRef(false);\n  const labelText = useText(label);\n  const textFieldProps = {\n    disabled,\n    variant,\n    label: !hideLabel && labelText,\n    fullWidth,\n    size,\n    type,\n    required,\n    error,\n    placeholder: placeholderText,\n    margin,\n    helperText: helper,\n    classes: {\n      root: classes.formControl\n    }\n  };\n  const searchProp = getProperty(searchProperty) || {};\n  const valueProp = getProperty(valueProperty) || {};\n  const [searchParam, setSearchParam] = useState('');\n  const [debouncedSearchParam, setDebouncedSearchParam] = useState('');\n  const {\n    filter\n  } = options;\n  const hasSearch = searchProp && searchProp.id;\n  const hasValue = valueProp && valueProp.id;\n\n  if (hasSearch && debouncedSearchParam !== '') {\n    filter[searchProp.id] = {\n      regex: debouncedSearchParam\n    };\n  } else if (hasSearch && debouncedSearchParam === '') {\n    delete filter[searchProp.id];\n  }\n\n  const hasNoProp = !hasSearch || !hasValue;\n  const reason = hasNoProp ? 'No property selected' : 'No data';\n  let inputProps = {\n    inputProps: {\n      tabIndex: isDev && -1\n    },\n    endAdornment: <>\n\t\t\t\t\t{currentValue && <Close />}\n\t\t\t\t\t{!freeSolo && <ExpandMore />}\n\t\t\t\t</>\n  };\n\n  if (multiple && currentValue) {\n    inputProps = { ...inputProps,\n      startAdornment: <Chip label={currentValue} onDelete={() => {}} />\n    };\n  }\n\n  const valueArray = currentValue ? currentValue.toString().split(',') : [];\n  const rawFilter = {\n    rawFilter: {\n      [valueProp.name]: {\n        in: valueArray\n      }\n    }\n  };\n  const [useFilter, setUseFilter] = useState(currentValue ? rawFilter : filter);\n\n  const resetFilter = () => {\n    setUseFilter({\n      filter\n    });\n  };\n\n  const orderByArray = [orderBy].flat();\n  const sort = !isDev && orderBy ? orderByArray.reduceRight((acc, orderByProperty, index) => {\n    const prop = getProperty(orderByProperty);\n    return index === orderByArray.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const {\n    loading,\n    error: err,\n    data: {\n      results\n    } = {},\n    refetch\n  } = model && useAllQuery(model, { ...useFilter,\n    skip: 0,\n    take: 50,\n    variables: { ...(orderBy ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    },\n\n    onCompleted(res) {\n      const hasResult = res && res.result && res.result.length > 0;\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(resp) {\n      if (!displayError) {\n        B.triggerEvent('onError', resp);\n      }\n    }\n\n  });\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (!isDev && results) {\n      resetFilter();\n    }\n  }, [results]);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n    }\n  }, [isDev, defaultValue]);\n  B.defineFunction('Clear', () => {\n    setCurrentValue(multiple ? [] : null);\n    setSearchParam('');\n  });\n  B.defineFunction('Refetch', () => refetch());\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedSearchParam(searchParam);\n    }, 1000);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchParam]);\n  useEffect(() => {\n    B.triggerEvent('onChange', currentValue);\n  });\n\n  const onChange = (_, newValue) => {\n    if (!valueProp || !newValue) {\n      setCurrentValue(newValue);\n      setCurrentLabel(newValue);\n      return;\n    }\n\n    let newCurrentValue = newValue[valueProp.name] || newValue;\n\n    if (typeof newValue === 'string') {\n      if (currentLabel === newValue) {\n        newCurrentValue = currentValue;\n      }\n    } else if (searchProp) {\n      const newLabelValue = newValue[searchProp.name];\n      setCurrentLabel(newLabelValue);\n    }\n\n    if (multiple) {\n      newCurrentValue = newValue.map(rec => rec[valueProp.name] || rec);\n    }\n\n    setCurrentValue(newCurrentValue);\n  };\n\n  const getRecords = React.useCallback(() => {\n    debugger;\n\n    if (!currentValue || !results) {\n      return multiple ? [] : null;\n    }\n\n    let currentRecordsKeys = currentValue;\n\n    if (!Array.isArray(currentValue)) {\n      currentRecordsKeys = multiple ? currentValue.toString().split(',') : [currentValue];\n    }\n\n    const currentRecords = results.reduce((acc, cv) => {\n      const searchStr = cv[valueProp.name].toString();\n      const search = cv[valueProp.name];\n\n      if (currentRecordsKeys.indexOf(searchStr) > -1 || currentRecordsKeys.indexOf(search) > -1) {\n        acc.push(cv);\n      }\n\n      return acc;\n    }, []);\n    const singleRecord = currentRecords[0] ? { ...currentRecords[0]\n    } : null;\n    return multiple ? currentRecords : singleRecord;\n  }, [currentValue, results]);\n  const record = getRecords();\n  useEffect(() => {\n    if (!multiple && record && searchProp) {\n      setCurrentLabel(record[searchProp.name]);\n    }\n  }, [record]);\n\n  const renderLabel = option => {\n    const optionLabel = option[searchProp.name];\n    return optionLabel !== undefined && optionLabel === '' ? '-- empty --' : optionLabel && optionLabel.toString() || option;\n  };\n\n  const renderOption = (option, {\n    selected\n  }) => <>\n\t\t\t\t<Checkbox classes={{\n      root: classes.checkbox\n    }} icon={<CheckBoxOutlineBlank fontSize='small' />} checkedIcon={<CheckBox fontSize='small' />} style={{\n      marginRight: 8\n    }} checked={selected} />\n\t\t\t\t{renderLabel(option)}\n\t\t\t</>;\n\n  if (isDev) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (kind === 'list' || kind === 'LIST') {\n    const onPropertyListChange = (_, newValue) => {\n      setCurrentValue(newValue);\n    };\n\n    const selectValues = listValues.map(({\n      value\n    }) => value).filter(e => e.startsWith(searchParam)) || [];\n    return <Autocomplete id='combo-box-demo' options={selectValues} value={currentValue} PopoverProps={{\n      classes: {\n        root: classes.popover\n      }\n    }} onInputChange={(_, inputValue) => {\n      setSearchParam(inputValue);\n    }} onChange={onPropertyListChange} getOptionLabel={option => option} renderInput={params => <TextField {...params} {...textFieldProps} name={nameAttributeValue || customModelAttributeName} key={currentValue ? 'hasValue' : 'isEmpty'} required={required && !currentValue} InputProps={{ ...params.InputProps,\n      endAdornment: params.InputProps.endAdornment\n    }} />} />;\n  }\n\n  if (!model) {\n    return <div className={classes.root}>\n\t\t\t\t\t<TextField {...textFieldProps} value={multiple ? '' : currentValue} InputProps={inputProps} />\n\t\t\t\t</div>;\n  }\n\n  if (err && displayError) return <span>{err.message}</span>;\n\n  if (!results || hasNoProp) {\n    return <TextField {...textFieldProps} defaultValue={reason} disabled InputProps={{\n      endAdornment: <CircularProgress color='inherit' size={20} />\n    }} />;\n  }\n\n  debugger;\n  return <Autocomplete multiple={multiple} freeSolo={freeSolo} options={results} value={record} inputValue={searchParam} getOptionLabel={renderLabel} getOptionSelected={(option, value) => value.id === option.id} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} onInputChange={(event, inputValue) => {\n    if (event) setSearchParam(inputValue);\n  }} onChange={onChange} disableCloseOnSelect={!closeOnSelect} renderOption={renderCheckboxes && renderOption} renderInput={params => <>\n\t\t\t\t\t\t<input type='hidden' key={currentValue ? 'hasValue' : 'isEmpty'} name={nameAttributeValue || customModelAttributeName} value={currentValue} />\n\t\t\t\t\t\t<TextField {...params} {...textFieldProps} required={required && (!currentValue || currentValue.length === 0)} loading={loading} InputProps={{ ...params.InputProps,\n      endAdornment: <>\n\t\t\t\t\t\t\t\t\t\t{loading ? <CircularProgress color='inherit' size={20} /> : null}\n\t\t\t\t\t\t\t\t\t\t{params.InputProps.endAdornment}\n\t\t\t\t\t\t\t\t\t</>\n    }} />\n\t\t\t\t\t</>} />;\n})()","styles":"B => t => {\n  const {\n    color: colorFunc,\n    Styling\n  } = B;\n  const style = new Styling(t);\n\n  const getOpacColor = (col, val) => colorFunc.alpha(col, val);\n\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    checkbox: {\n      color: ({\n        options: {\n          checkboxColor\n        }\n      }) => [style.getColor(checkboxColor), '!important'],\n      '&.MuiCheckbox-root.Mui-checked:hover, &.MuiIconButton-root:hover': {\n        backgroundColor: ({\n          options: {\n            checkboxColor\n          }\n        }) => [getOpacColor(style.getColor(checkboxColor), 0.04), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            variant\n          }\n        }) => variant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        },\n        '& .MuiChip-root': {\n          color: ({\n            options: {\n              textColorChip\n            }\n          }) => [style.getColor(textColorChip), '!important'],\n          backgroundColor: ({\n            options: {\n              backgroundColorChip\n            }\n          }) => [style.getColor(backgroundColorChip), '!important']\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Refetch"],"triggers":["onSuccess","onNoResults","onError","onLoad","onChange"],"interactions":{},"componentHash":"70f5d39205ad984328e618734f288cd24c5e209fc2561b63cf03f6e80cb903f3"},{"name":"CustomCheckbox","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    error,\n    disabled,\n    position,\n    size,\n    helperText,\n    customModelAttribute: customModelAttributeObj,\n    validationValueMissing,\n    nameAttribute,\n    isSwitch\n  } = options;\n  const {\n    env,\n    useText,\n    getCustomModelAttribute\n  } = B;\n  const isDev = env === 'dev';\n  const [errorState, setErrorState] = useState(error);\n  const [helper, setHelper] = useState(useText(helperText));\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const labelText = useText(label);\n  const componentChecked = useText(defaultValue);\n  const [checked, setChecked] = useState(componentChecked === 'true');\n  const nameAttributeValue = useText(nameAttribute);\n  const {\n    Checkbox: MUICheckbox,\n    Switch,\n    FormControlLabel,\n    FormControl,\n    FormHelperText\n  } = window.MaterialUI.Core;\n  B.defineFunction('ResetCheckbox', () => setChecked(componentChecked === 'true'));\n\n  const handleValidation = isChecked => {\n    const valid = isChecked && required || !required;\n    setErrorState(!valid);\n    const message = useText(!valid ? validationValueMissing : helperText);\n    setHelper(message);\n  };\n\n  const handleChange = evt => {\n    const {\n      checked: isChecked\n    } = evt.target;\n    B.triggerEvent('onCustomChange', isChecked);\n    handleValidation(isChecked);\n    setChecked(isChecked);\n  };\n\n  useEffect(() => {\n    if (checked) {\n      B.triggerEvent('isTrue', true);\n    } else {\n      B.triggerEvent('isFalse', false);\n    }\n  }, [checked]);\n  useEffect(() => {\n    if (isDev) {\n      setChecked(useText(defaultValue) === 'true');\n    }\n  }, [isDev, defaultValue]);\n  const props = {\n    checked,\n    onChange: handleChange,\n    name: nameAttributeValue || customModelAttributeName,\n    disabled,\n    size,\n    tabIndex: isDev && -1,\n    value: 'on'\n  };\n  const Checkbox = <MUICheckbox {...props} />;\n  const SwitchComponent = <Switch {...props} />;\n  const Control = <FormControl required={required} error={errorState} classes={{\n    root: classes.formControl\n  }}>\n\t\t\t\t<FormControlLabel control={isSwitch ? SwitchComponent : Checkbox} label={labelText} labelPlacement={position} />\n\t\t\t\t{!!helper && <FormHelperText>{helper}</FormHelperText>}\n\t\t\t</FormControl>;\n  return isDev ? <div className={classes.root}>{Control}</div> : Control;\n})()","styles":"B => t => {\n  const {\n    color: colorFunc,\n    Styling\n  } = B;\n  const style = new Styling(t);\n\n  const getOpacColor = (col, val) => colorFunc.alpha(col, val);\n\n  return {\n    root: {\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    formControl: {\n      '& > legend': {\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiFormControlLabel-root': {\n        '& .MuiCheckbox-root': {\n          color: ({\n            options: {\n              checkboxColor\n            }\n          }) => [style.getColor(checkboxColor), '!important'],\n          '&:hover': {\n            backgroundColor: ({\n              options: {\n                checkboxColor\n              }\n            }) => [getOpacColor(style.getColor(checkboxColor), 0.04), '!important']\n          },\n          '&.Mui-checked': {\n            color: ({\n              options: {\n                checkboxColorChecked\n              }\n            }) => [style.getColor(checkboxColorChecked), '!important'],\n            '&:hover': {\n              backgroundColor: ({\n                options: {\n                  checkboxColorChecked\n                }\n              }) => [getOpacColor(style.getColor(checkboxColorChecked), 0.04), '!important']\n            }\n          }\n        },\n        '& .MuiSwitch-root': {\n          '& .MuiSwitch-track': {\n            backgroundColor: ({\n              options: {\n                checkboxColor\n              }\n            }) => [style.getColor(checkboxColor), '!important']\n          },\n          '& .Mui-checked': {\n            color: ({\n              options: {\n                checkboxColorChecked\n              }\n            }) => [style.getColor(checkboxColorChecked), '!important'],\n            '&:hover': {\n              backgroundColor: ({\n                options: {\n                  checkboxColorChecked\n                }\n              }) => [getOpacColor(style.getColor(checkboxColorChecked), 0.04), '!important']\n            }\n          },\n          '& .Mui-checked ~ .MuiSwitch-track': {\n            backgroundColor: ({\n              options: {\n                checkboxColorChecked\n              }\n            }) => [style.getColor(checkboxColorChecked), '!important']\n          }\n        },\n        '& .MuiTypography-root': {\n          color: ({\n            options: {\n              textColor\n            }\n          }) => [style.getColor(textColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      }\n    }\n  };\n}","functions":["ResetCheckbox"],"triggers":["onCustomChange","isTrue","isFalse"],"interactions":{},"componentHash":"821236359e92439b2d77a2be6fc9840041d123da417df6079ecbbee2064c2dcb"},{"name":"CustomDateTimePicker","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    enableDates,\n    model,\n    filter,\n    enabledDateProperty,\n    disabled,\n    error,\n    placeholder,\n    disableManual,\n    variant,\n    clearable,\n    inputvariant,\n    type,\n    dateFormat,\n    timeFormat,\n    dateTimeFormat,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    disableToolbar,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    use24HourClockDateTime,\n    use24HourClockTime,\n    nameAttribute,\n    locale\n  } = options;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText,\n    getProperty,\n    useAllQuery,\n    useFilter\n  } = B;\n  const {\n    MuiPickersUtilsProvider,\n    KeyboardTimePicker,\n    KeyboardDatePicker,\n    KeyboardDateTimePicker\n  } = window.MaterialUI.Pickers;\n  const {\n    DateFnsUtils\n  } = window.MaterialUI;\n  const {\n    nlLocale,\n    enLocale\n  } = window.MaterialUI.DateLocales;\n  const {\n    AccessTime,\n    Event\n  } = window.MaterialUI.Icons;\n  const DateFns = new DateFnsUtils();\n  const isDev = env === 'dev';\n  const [selectedDate, setSelectedDate] = useState(null);\n  const helper = useText(helperText);\n  const placeholderText = useText(placeholder);\n  const enabledDatesProp = getProperty(enabledDateProperty) || {};\n  const [enabledDates, setEnabledDates] = useState([]);\n  const [currentDate, setCurrentDate] = useState(new Date());\n  const localeMap = {\n    nl: nlLocale,\n    en: enLocale\n  };\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const strDefaultValue = useText(defaultValue);\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n\n  const isValidDate = date => date instanceof Date && !isNaN(date);\n\n  const monthChanged = date => {\n    setCurrentDate(date);\n  };\n\n  const getFirstDayOfTheMonth = () => {\n    const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);\n\n    if (enabledDatesProp.kind === 'date') {\n      firstDay.setMinutes(currentDate.getMinutes() - currentDate.getTimezoneOffset());\n      return firstDay.toJSON().slice(0, 10);\n    }\n\n    return firstDay.toISOString();\n  };\n\n  const getLastDayOfTheMonth = () => {\n    const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);\n\n    if (enabledDatesProp.kind === 'date') {\n      lastDay.setMinutes(currentDate.getMinutes() - currentDate.getTimezoneOffset());\n      return lastDay.toJSON().slice(0, 10);\n    }\n\n    return lastDay.toISOString();\n  };\n\n  if (!isDev && enableDates) {\n    const mergedFilter = { ...useFilter(filter),\n      ...{\n        [enabledDatesProp.name]: {\n          gteq: getFirstDayOfTheMonth(),\n          lteq: getLastDayOfTheMonth()\n        }\n      }\n    };\n    const {\n      loading,\n      error: err,\n      data: {\n        results\n      } = {},\n      refetch\n    } = model && useAllQuery(model, {\n      rawFilter: mergedFilter,\n      skip: 0,\n      take: 200,\n\n      onCompleted(res) {\n        const hasResult = res && res.results && res.results.length > 0;\n\n        if (hasResult) {\n          setEnabledDates(res.results.map(item => item[enabledDatesProp.name]));\n          B.triggerEvent('onSuccess', res.results);\n        } else {\n          B.triggerEvent('onNoResults');\n        }\n      },\n\n      onError(resp) {\n        B.triggerEvent('onError', resp);\n      }\n\n    });\n  }\n\n  const changeHandler = date => {\n    setSelectedDate(date);\n  };\n\n  const setDefaultDate = (defaultFormat, givenFormat) => {\n    if (!selectedDate && strDefaultValue) {\n      const propDefaultParse = defaultFormat ? DateFns.parse(strDefaultValue, defaultFormat) : new Date(strDefaultValue);\n      const formatDefaultParse = DateFns.parse(strDefaultValue, givenFormat);\n\n      if (isValidDate(propDefaultParse)) {\n        setSelectedDate(propDefaultParse);\n      } else if (isValidDate(formatDefaultParse)) {\n        setSelectedDate(formatDefaultParse);\n      } else {\n        setSelectedDate(DateFns.parse('00:00:00', 'HH:mm:ss'));\n      }\n    }\n  };\n\n  const disableDates = date => {\n    const compareDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toJSON().slice(0, 10);\n    const matchingDate = enabledDates.find(dateItem => dateItem === compareDate);\n\n    if (matchingDate != undefined) {\n      return false;\n    }\n\n    return true;\n  };\n\n  B.defineFunction('Clear', () => setSelectedDate(null));\n  let DateTimeComponent;\n  let format;\n  let resultString;\n  let use24HourClock = true;\n\n  switch (type) {\n    case 'date':\n      {\n        DateTimeComponent = KeyboardDatePicker;\n        format = dateFormat || 'dd/MM/yyyy';\n        setDefaultDate('yyyy-MM-dd', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'yyyy-MM-dd') : null;\n        break;\n      }\n\n    case 'datetime':\n      {\n        DateTimeComponent = KeyboardDateTimePicker;\n        format = dateTimeFormat || 'dd/MM/yyyy HH:mm:ss';\n        use24HourClock = use24HourClockDateTime;\n        setDefaultDate(null, format);\n        resultString = isValidDate(selectedDate) ? new Date(selectedDate).toISOString() : null;\n        break;\n      }\n\n    case 'time':\n      {\n        DateTimeComponent = KeyboardTimePicker;\n        format = timeFormat || 'HH:mm:ss';\n        use24HourClock = use24HourClockTime;\n        setDefaultDate('HH:mm:ss', format);\n        resultString = isValidDate(selectedDate) ? DateFns.format(selectedDate, 'HH:mm:ss') : null;\n        break;\n      }\n\n    default:\n  }\n\n  const DateTimeCmp = <DateTimeComponent name={nameAttributeValue || customModelAttributeName} value={selectedDate} size={size} classes={{\n    root: classes.formControl\n  }} variant={variant} clearable={clearable} placeholder={placeholderText} fullWidth={fullWidth} onChange={changeHandler} onMonthChange={monthChanged} inputVariant={inputvariant} InputProps={{\n    inputProps: {\n      name: nameAttributeValue || customModelAttributeName,\n      tabIndex: isDev && -1,\n      readOnly: disableManual ? true : false\n    }\n  }} KeyboardButtonProps={{\n    tabIndex: isDev && -1\n  }} required={required} disabled={disabled} label={!hideLabel && labelText} error={error} margin={margin} helperText={helper} disableToolbar={disableToolbar} format={format} PopoverProps={{\n    classes: {\n      root: classes.popover\n    }\n  }} DialogProps={{\n    className: classes.dialog\n  }} ampm={!use24HourClock} shouldDisableDate={disableDates} keyboardIcon={type === 'time' ? <AccessTime /> : <Event />} />;\n  return isDev ? <div className={classes.root}>\n\t\t\t\t<MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t\t</MuiPickersUtilsProvider>\n\t\t\t</div> : <MuiPickersUtilsProvider utils={DateFnsUtils} locale={localeMap[locale]}>\n\t\t\t\t<input type='hidden' name={nameAttributeValue || customModelAttributeName} value={resultString} />\n\t\t\t\t{variant === 'static' ? <div className={classes.static}>{DateTimeCmp}</div> : DateTimeCmp}\n\t\t\t</MuiPickersUtilsProvider>;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    dialog: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      },\n      '& .MuiButton-textPrimary': {\n        color: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    popover: {\n      '& .MuiPickersToolbar-toolbar, & .MuiPickersDay-daySelected': {\n        backgroundColor: ({\n          options: {\n            backgroundColorPopup\n          }\n        }) => [style.getColor(backgroundColorPopup), '!important']\n      }\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            inputvariant\n          }\n        }) => inputvariant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    },\n    static: {\n      '& .MuiPickersStaticWrapper-staticWrapperRoot': {\n        '& .MuiToolbar-root, & .MuiPickersDay-daySelected': {\n          backgroundColor: ({\n            options: {\n              backgroundColorPopup\n            }\n          }) => [style.getColor(backgroundColorPopup), '!important']\n        }\n      }\n    }\n  };\n}","functions":["Clear"],"triggers":["onSuccess","onNoResults","onError"],"interactions":{},"componentHash":"cbdc174aa3d212a4959da97d78e75c250678f6e3967df4b10b7ed50337dd817f"}]
